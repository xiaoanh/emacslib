# % Time-stamp: "xiaoanh 2015/12/22 14:15:26" 
#+CATEGORY: Work
# #+FILETAGS: :@tool:
# #+TAGS: @tool(t)

* TODO [#B] MFH, TDD Symbol cascading, [2014-12-30 Tue]

** CPRI

*** OOK-based, digital
    common public radio interface (CPRI) that transmits digitized baseband signals via on-off-keying (OOK). 
    However, the OOK based CPRI is not spectrally effective and requires
    expensive high-speed optical transmitter and receiver to support high
    data rate.

** Closed FDD [2014-12-30 Tue]


** ACCORDANCE, Converged Copper-Optical-Radio

*** DSL (Digital Subscriber Line) using copper

*** http://www.ict-accordance.eu/Eng

*** intro
  1) A Converged Copper-Optical-Radio OFDMA-based access Network with
     high Capacity and Flexibility


* Standard

** Wireless Fronthaul Transport Solutions over Access System (ITU-T G.989.1)

** WiMAX, 802.16, similar to WiFi, SOFDMA
  1) WiMAX is sometimes referred to as "Wi-Fi on steroids"[4] and can
     be used for a number of applications including broadband
     connections, cellular backhaul, hotspots, etc. It is similar to
     Wi-Fi, but it can enable usage at much greater distances.[5]
  2) calable orthogonal frequency-division multiple access[16] (SOFDMA)


* TODO [#B] PON, [2015-01-08 Thu]

** conherent

 1) Coherent systems need carrier phase information at the receiver
    and they use matched filters to detect and decide what data was
    sent , while noncoherent systems do not need carrier phase
    information and use methods like square law to recover the data. 


** 流氓ONU, Rogue PON, NO power off
1) 正常ONU是在指定时间发送数据，发送完毕后关闭激光器，等待下一次发送时
   间流氓ONU是指它一直发送数据，造成其它ONU无法发送数据，在此OLT上的其
   它ONU都会掉线一般都是光模块损坏，激光器不能关断造成的



** share total BW: 20MHz*Nchn


* TODO [#B] @key: MATLAB MFH

** [#C] @key: CA8x1v12sd12s1.m for combined SD-E-UTRA, success [2015-04-23 Wed]
% sum(BW)|54.4-MHz 
*** for zmapr, [2015-04-23 Thu]
  % @key:, if---end must outside of for jj end, [2015-04-23]
    if kk ==1
        mm = 0;
    else
        mm = mm+Nsd(kk-1);
    end
    for jj = 1:OFDM.numRun
        zmapr = [zmapr;zmapall(mm+1:mm+Nsd(kk),jj)];
    end
    

** [#C] @key: CA8x1v12sd12.m for combined SD-E-UTRA, success [2015-04-22 Wed]

*** for kk = Nbw1+1:Nbw

*** xifftCI = []; % KEY, must put here, [2015-04-22]

*** mm2 and jj
   elseif kk >Nbw1
            %             jj = 0;
            %             mm = mm+OFDM.FFTsize(kk-1)*Qc/Nbw*(kk-1);
            %             mm = mm+OFDM.FFTsize(kk-1)*Qc/Nbw;
            mm2 = mm2+OFDM.FFTsize(kk-1)*Qc/Nbw;
            %             mm2 = mm2+OFDM.FFTsize(kk-1)*Qc/Nbw;
            jj = (kk-1)*Qc/Nbw+1;
            
            yrx_ifft = yrxC(mm2+1:mm2+Nfft).*exp(-1i*2*pi*(jj-1)/Qc);
        end


** [#B] @key: CA8x1v2sd1.m for ICA-E-UTRA, success [2015-04-22 Wed]
  1) CA8x1v2sd12_conste64 for all 64-QAM
  2) EVM  = sqrt(mean((i_tx-i_rx).^2+(q_tx-q_rx).^2))/abs(max(xmapr));
  3) EVM = round(1000*EVM)/1000; % get only 3, [2015-04-23]
*** | jj | mm |, | IF num| data|, only need to decode 1st for each BW
        if kk == 1
            mm = 0;
        else
            %             jj = 0;
            %             mm = mm+OFDM.FFTsize(kk-1)*Qc/Nbw*(kk-1);
            mm = mm+OFDM.FFTsize(kk-1)*Qc/Nbw;
        end
%         yrxC0 = yrxC(mm+1:mm+Nfft);
        jj = (kk-1)*Qc/Nbw+1;
        yrx_ifft = yrxC(mm+1:mm+Nfft).*exp(-1i*2*pi*(jj-1)/Qc);


***  xifftC =[];   % KEY, must put here, [2015-04-22]


** [#C] @key: CA8x1v12sd1.m for DFT-S-E-UTRA, success [2015-04-17 Fri]
  1) (3.84+7.68+15.36+23.04+30.72)*6=80.64*6
  2) (16+32+64+128+192+256) = 688

*** OFDM.M
OFDM.M = [4 4 16 16 64 64]; % % [2015-04-15]

*** scatterplot
for kk = 1:Nbw
    zmapr = [];
    for jj = 1:OFDM.numRun
        if kk ==1
            mm = sum(Nsd)*(jj-1);
        else
            mm = sum(Nsd)*(jj-1)+Nsd(kk-1);
        end
        zmapr = [zmapr zmapall(mm+1:mm+Nsd(kk))];
    end
    scatterplot(zmapr,1,0,'b+');	% [2015-02-05]
    title([num2str(OFDM.M(kk)), '-QAM',', SNR: ', num2str(snr)]);
    % [2015-02-28]
    legend('RX', 'TX');
    clear zmapr;
end


** [#B] @key: CA8x1v12.m for E-UTRA success [2015-04-15 Wed]

***  max(OFDM.FFTsize)*Qc;  % @key: HXA, [2015-04-15]
% OFDM.FFTsizeC = OFDM.FFTsize(end)*Qc;  % for CA, [2015-04-02]
OFDM.FFTsizeC = max(OFDM.FFTsize)*Qc;  % @key: HXA, [2015-04-15]

*** xfftC = [xfftC repmat(xfftC0,1,Qc/Nbw)]; % otherwise, inverse
%         xfftC = [repmat(xfftC0,1,Qc/Nbw) xfftC]; 
        xfftC = [xfftC repmat(xfftC0,1,Qc/Nbw)]; % @key:, [2015-04-15]

*** mm for index of each band
        if kk == 1 
            mm = 0;
        else
%             jj = 0; 
%             mm = mm+OFDM.FFTsize(kk-1)*Qc/Nbw*(kk-1);
            mm = mm+OFDM.FFTsize(kk-1)*Qc/Nbw;
        end

** [#B] @key:: CA8x1v2.m, NfftC, [2015-03-05 Thu]
        xifftC =[]; 
        for kk = 1:Qc;
           %  xifftC1 = xifftC0*exp(1i*pi*(kk-1)/NfftC);
	   xifftC1 = xifftC0*exp(1i*pi*(kk-1)/Qc);
            xifftC = [xifftC xifftC1]; % [2015-03-05]
        end 

** [#B] @key:: CA8x1v1.m, NfftC

Qc = 16; 
OFDM.FFTsizeC = OFDM.FFTsize*Qc;  % for CA, [2015-03-05]

*** CA
        xmap=bi2map(xbi,k);

        xifft = ifft(xmap',OFDM.FFTsize);
       %% CA8x1, HXA<2014-12-25>
        % KEY: from SLMsuanfa.m
        
        xifftC0 = fft(xifft,Nfft);
%         xifftC = ifft([xifftC0 xifftC0 xifftC0 xifftC0],NfftC); % [2015-03-05] 
        xifftC = ifft(repmat(xifftC0,1,Qc),NfftC); % [2015-03-05] 
        
%         xifftC0 = xifft;
%         xifftC = fft([xifftC0 xifftC0 xifftC0 xifftC0],NfftC); % [2015-03-05]
        
%         xtx = [xifft(Nfft-OFDM.CPsize+1:Nfft) xifft];
        xtx = [xifftC(NfftC-NcpC+1:NfftC) xifftC];   % [2015-03-05]


*** size
zmapr = reshape(zmapall,size(zmapall,2)*size(zmapall,1),1); 


**  [#A] HXA_CoMO150105.m
from HXA_OFDM_trx_BW_141230s2.m
*** 1024QAM, *Nfft1024*

1) Preamble = 2*randi(1,Nsd)-1;  % @key:, [2015-02-05]
# @key:, training just changed into randi, BER is 0,

2) M  = 1024; % 16 into 256, [2015-02-05]
% @key: QAM|64|256|1024, BER|0|0.01(Nfft=64)|0(Nfft=1024), [2015-02-05]

3) Preamble = 2*randint(1,Nsd)-1;  % @key:, [2015-02-05] 
% @key: 27|25|26, Nsd/2+1|Nsd/2-1|Nsd/2

*** *test again, BER IS 0, REVISED*, [2015-02-04 周三]

**** Finally *PERFECT, filter eq before downsample, last Eq map*, *ceil(Nflt/Q*
1) code REVISED
    xflt = filter(hh,1,upsample([xchn; zeros(ceil(Nflt/Q),1)],Q)); % @key:
    HXA [2015-02-04]
    zflt = filter(hh,1,zcomp); % uses an order n FIR filte
    % zchn = downsample(zflt,Q); % HXA<2015-01-06>
    zflt_equa = zflt(Nflt+1:end);  % @key: HXA[2015-02-04]
    zchn = downsample(zflt_equa,Q);
2) QAM|4|16, BER |0|0, EVM |0.048|0.028, Const|R|R

**** test
    1) filter add zeros(Nflt,1),
       1) xflt = filter(hh,1,upsample([xchn; zeros(Nflt,1)],Q)); % @key: HXA [2015-02-04]
       2) if Gap_index = 1/2; Consta is perfect
	  1) Gap_index = 1/2;  % Nflt is 72, KEY: <2015-01-06>
       3) if Gap_index = 1/10; Consta is perfect
       4) Gap_index = 1/10;  % 1/2|1/10, Nflt is 72|358, KEY: [2015-02-04 周三]
*** test [2015-01-05 周一]
2) xchn = [ofdm_sig zeros(1,Nfft*2-Ns*1)];	% 256 into Nfft*2,
   [2015-01-05 周一]
   zfltQ = filter(hh,1,Qrx); zfltI1 = zfltI(n+1:end); % KEY: HXA <2014-12-31>
3) Half_Bandwidth_index = 1/2; % 1/2 into 1(error), <2015-01-06>
% Gap_index = 1/20; % 1/20, n is 715; 1/10, n is 358;  1/5, n is 179.
Gap_index = 1/2;  % KEY: <2015-01-06>


**  [#B] @key:: CHANGE FDD TO TDD by Kaibin, <2015-01-05 Mon>

*** CoMO-Convergence of Mobile and Optics

 
**  [#B] MFH, scfdma, 32CH_Part_1_version256QAM_2_Gen.m <2014-12-09 Tue>

*** [#A] KEY: MFH141229s1.m 
% from HXA_OFDM_trx_BW_141230s2.m <2015-01-04 周日>
% from I_32CH_Part_1_version256QAM_2_Gen141226s4.m
% COPYRIGHT: HXA<2014-12-29>

*** [#A] KEY: to be simple. right. 32CH_Part_1_version256QAM_2_Gen141226s1.m
*OVERTIME@HOME, <2014-12-26 周五>*
1) IF1_I_Recovered_B4_LPF
   1) IF1_I_Recovered_B4_LPF = Multi_IF_S.*IF1_cos;
2) IF1_I_Recovered_After_LPF
3) IF_Max, Num_IFs same as NoEp, line277 
  Num_IFs is 268800
  IF_Max is 80, Nfrm is 1, Ns is 80
  268800/80/80/2
  Num_IFs = Ns*(Nd+1)*Nfrm*IF_Max*2;
  dt = 1/Num_IFs;

4) NoEP
   NoEED = Ns * (Nd+1) *2; % Number of Effective Data (Pure Data
   WITHOUT Carrirt LO) 3360
    NoEP = NoEED * IF_Max

5) Multi_IF_S
    Multi_IF_S: IF5_S_Fltd to IF16_S_Fltd
    % Multi_IF_S = Multi_IF_S/10*1;
    Multi_IF_S = Multi_IF_S/2*1;
    Multi_IF_S =   0.8*IF5_S_Fltd + .9*IF6_S_Fltd + 1*IF7_S_Fltd
    +1.1*IF8_S_Fltd +2.0*IF9_S_Fltd+ IF10_S_Fltd + 1.02*IF11_S_Fltd + 1.03*IF12_S_Fltd +
   1.04*IF13_S_Fltd + 1.05*IF14_S_Fltd + 1.06*IF15_S_Fltd+
    1.08*IF16_S_Fltd;

6) IF_Max 80 into 40
    Q: why 160. data16S_80. No run error, but Constellation error
    data16S_40 = reshape(data16S_40',80*Ns*(Nd+1)*Nfrm,1); %  HXA, <2014-12-26>
    data16S_80  = data16S_40; % change IF_Max into 40, HXA<2014-12-26>
    data16S_80 = reshape(data16S_80',160*Ns*(Nd+1)*Nfrm,1); %  HXA,
    <2014-12-09>
   
    error is ??? Error using ==> reshape
    Ans: delete msg160 and IF1_S
    line316 % IF1_S_Fltd = 2*filter(hh,1,IF1_S);
    msg160 = reshape(msg160,NoEP,1);

7) Start_Rx
    % for Start_Rx = -20:2:-20
    Start_Rx = 2; % HXA<2014-12-26>
8) BER, Rx_Flt_HH_L is 52*20, and msg2 is 52*19
   M2=64;              % 16-QAM调制
   Nd from 20 into 10, right
   data4=[data4i(Nffta-Ncp+1:end,:); data4i];  % HXA<2014-12-26>
   data2=qammod(msg2,M2)/sqrt(16);  % 16-QAM, HXA
   % x4=qamdemod(Rx_Flt_HH_M,M2); 
   % X4=reshape(x4,52,Nd);
   % [neb4,temp]=biterr(X4,X4_o,log2(M2));
9) delete Preamble
data4(1:Nsp,:)=data2; % HXA, <2014-12-26>

% data4(2:27,:)=data2(27:end,:);
% data4(Nfft-25:end,:)=data2(1:26,:); % HXA, <2014-12-09>
data4(1:Nsp,:)=data2; % HXA, <2014-12-26>


**** 基于MATLAB频分复用系统的研究与仿真设计, cheby2
n,Wn,beta,ftype] = kaiserord(f,a,dev,fs)
 The length of f is twice the length of a, minus 2.
mags = [1 0]; % LPF, %/141226
devs = [0.05 10^(-2.5)];

Chebyshev Type II filter using specification object
matlab code 
[n1,Wn1]=cheb2ord(Wp1,Ws1,Rp,Rs); 
[b1,a1]=cheby2(n1,Rs,Wn1); 
[h1,w1]=freqz(b1,a1); 


*** [#A] I_32CH_Part_1_version256QAM_2_Gen141226s3.m, only preamble
<2015-01-06 周二>
*** [#A] KEY: LTE下行链路OFDM系统的MATLAB实现 from WENKU
**** [#A] KEY: LTE_DS_OFDM.m, .*sqrt(16)
1) zsym=qamdemod(Rx_Flt_FFT_4.*sqrt(16),M2);  % :KEY: very careful,
     HXA, M2 is 64

2) [neb4,BER]=biterr(zsym,msg2,log2(M2)); % delete (:,3:end), BER is 0, HXA<2014-12-16>
% end

          r1=1*dd1+sigma1*(randn(1,length(dd1))+j*randn(1,length(dd1)));  
          % hh into 1, HXA<2014-12-26>
          %         x1=r1(:,2:end)./hh(:,2:end);  %信道补偿
          %         x2=r2(:,2:end)./hh(:,2:end);
          x1=r1(:,2:end);  % HXA,信道补偿

*** filter_multi_IF function, line 1240, dense IF channels

*** [#B] preamble, must change at TX and Rx, line2048, if Qsc ==1 else end
根据训练符号进行的信道估计
    Rx_Flt_FFT_40 = fft(r2_2); % 256*21, HXA, <2014-12-15>
    %    Rx_Flt_FFT_41 = zeros(1,Nffta);
%     Rx_Flt_FFT_41 = Rx_Flt_FFT_40(1:Qsc:Nffta);
    Rx_Flt_FFT_41 = Rx_Flt_FFT_40(1:Qsc:Nffta, :);
    % must add ,:, 64*21, HXA, <2014-12-15>
    Rx_Flt_FFT_4= ifft(Rx_Flt_FFT_41);

*** Error BB_Extnt, is double, solved must put in same dir [2014-12-09 Tue]
  
Error in ==> I_32CH_Part_1_version256QAM_2_Gen at
398
       [IF_S_Fltd OFDM_IF_F h1] =
       filter_multi_IF(IF_Num, IF_Max, BB_Extnt,
       Num_IFs); 


*** sim1_case1_LTE.m [2014-12-09 Tue]

**** http://www.codebus.net/d-Gen9.html
*** preamble, HH2, 通过设计训练序列或在数据中周期性地插入导频符号来进行估计的
    - t=0:ts:(Ns*(Nd+1)*Nfrm-1)*ts; % 抽样时刻 %plot (IF1_I);  fd=100;
      % 最大多普勒频移
    -               %%%%%%%%%%%%%% 根据训练符号进行的信道估计 %%%%%%%%%%%----Start-----%%%%%%%%%%%%  

	Rx_Flt_FFT_4=fft(r2_2);                         % fft运算
	    
	Rx_Flt_FFT_4=[Rx_Flt_FFT_4(39:end,:);Rx_Flt_FFT_4(2:27,:)];             % 数据重排
	 %HH1=(Preamble.')./R1(:,1);                  % 信道估计
	HH2=(Preamble.')./Rx_Flt_FFT_4(:,1);                   
	
	%HH1=HH1*ones(1,Nd);                         % 根据信道估计结果进行信道补偿
	HH2=HH2*ones(1,Nd);

	%x3=R1(:,2:end).*HH1;                        
	Rx_Flt_HH_M=Rx_Flt_FFT_4(:,2:end).*HH2;
	
	   %%%%%%%%%%%%%% 根据训练符号进行的信道估计
	      %%%%%%%%%%%%%----END-----%%%%%%%%%%
	      Rx_Flt_HH_L=reshape(Rx_Flt_HH_M,Nsp*Nd,1)

*** HXA scfdma, PAPR, line: 1766

**** PAPR is 24-dB w/o SCFDMA
FFT size 64, w/o SC, PAPR is 24dB
FFT size 64*4, w/o SC, PAPR is 28.7dB
FFT size 64*4, w SC,- PAPR is 23dB

line218 delete load fix data
% data16S = data16S_3360.data6S;
data16S = data6S; % HXA <2014-12-09>

line447
data64S_80 data128S_80 
line125
data2=qammod(msg2,M2)/sqrt(16);  % 16-QAM, HXA

line170, so preamble1 must Nffta
  data5(:,(indx-1)*(Nd+1)+1)=preamble1.';
    data5(:,(indx-1)*(Nd+1)+2)=preamble1.';

line112
Preamble1(Nffta-25:end)=Preamble(1:26); % HXA, <2014-12-09>


line167, Ns or Ns0
data5=zeros(Ns,(Nd+1)*Nfrm);                % 加入训练符号

line275 Ns must Nffta
data16S_80 = reshape(data16S_80',160*Ns*(Nd+1)*Nfrm,1);

line94, ts must Nsa
ts=1/sr/Nsa/Nfrm;                    % HXA, OFDM符号抽样时间间隔

line400 data16S_80 must change
IF2_cos <1075200x1 double>
data16S_80 <268800x1 double>
IF2_S = data16S_80.*IF2_cos;   % 只测实数，暂时不计算复数形式！！

line215 data6S_3360 load .mat

line125 fix data
data2=qammod(msg2,M2)/sqrt(81);             % 64-QAM调制并归一化

line276
data16S_80 = reshape(data16S_80',160*Ns0*(Nd+1)*Nfrm,1); %  HXA, <2014-12-09>
% data16S_80 = reshape(data16S_80',160*Ns*(Nd+1)*Nfrm,1);

line179, 
data3 is 80*19
data5 is 1680*1, 1680/80=21,  19 into 21
% clear data3 data4

line1983

line2012 preamble
   Rx_Flt_FFT_4=[Rx_Flt_FFT_4(Nffta-25:end,:);Rx_Flt_FFT_4(2:27,:)];
   % 数据重排, HAX, <2014-12-09>

%% SC-FDMA, HXA, <2014-12-09>
line141
X3 = fft(data3); % HXA, <2014-12-09>
data3 = zeros(Nfft,19);
data3(1:Qsc:Nfft,:) = X3;
X4 = fft(data4);
data4 = zeros(Nfft,19);
data4(1:Qsc:Nfft,:) = X4;% HXA, <2014-12-09>

line29
Ns=Nfft+Ncp;        % 1个完整OFDM符号长度

line229, line237-246 
53760/3360=16
3360/80=42
Ns=80, Nd=20
FFT_Box <53760x1 double> 
data 16S<3360x1 double>
FFT_Box = zeros(8*Ns*(Nd+1),1);
FFT_Box (1:2*Ns*(Nd+1)) = (data16S);

Ctrl-F, replaced 39-->Nfft-25
line134
data4(Nfft-25:end,:)=data2(1:26,:); % HAX, <2014-12-09>
% data4(39:end,:)=data2(1:26,:);

line: 110
Preamble1(Nfft-25:end)=Preamble(1:26); % HXA, <2014-12-09>
% Preamble1(39:end)=Preamble(1:26);

line: 1766
y_result = Multi_IF_S; % HXA, <2014-12-09>
PAPR = 10*log10(max(abs(y_result).^2) / mean(abs(y_result).^2));  %
HXA, <2014-12-09>

     Multi_IF_S =                    0.8*IF5_S_Fltd + .9*IF6_S_Fltd + 1*IF7_S_Fltd +1.1*IF8_S_Fltd +2.0*IF9_S_Fltd+ ...
     IF10_S_Fltd + 1.02*IF11_S_Fltd + 1.03*IF12_S_Fltd +
     1.04*IF13_S_Fltd + 1.05*IF14_S_Fltd + 1.06*IF15_S_Fltd+
     1.08*IF16_S_Fltd;


*** OVERTIME@HOME doc kaiserord, fir1 and fir2, [2014-12-31 Wed] 
- fcuts = [0.1/3  0.1225/3]; %归一化频率omega/pi，这里指通带截止频率、阻带起始频率
      mags = [1 0];
      devs = [0.05 10^(-2.5)];
      [n,Wn,beta,ftype] = kaiserord(fcuts,mags,devs);  %计算出凯塞窗N,
      beta的值  
  hh = fir1(n,Wn,ftype,kaiser(n+1,beta),'noscale'); 
  IF1_S_Fltd = 2*filter(hh,1,IF1_S);
- fir1 for windows-based standard lowpass, bandpass, highpass, and
  bandstop configurations.
- fir2 designs frequency sampling-based digital FIR filters 


**  [#B] HXA_OFDM_trx_BW_141230s2.m, 				      :@home:

*** filter, Half_Bandwidth_index, <2015-01-07 周三>
IF_index = 3;
Half_Bandwidth_index = 1/2; % fixed, otherwise, error, <2015-01-07>

Nsd    = Nu*120;   % 100 into 120, <2015-01-07> % change, 130728

*** PBFtx.m
1) NOTE: PBF
   %% pass-band filter-(PBF), <2015-01-04>
   IF_index = 5;
   Half_Bandwidth_index = 1/2;
   Gap_index = 1/20;
   ws1 = IF_index-Half_Bandwidth_index-Gap_index;
   wp1 = IF_index-Half_Bandwidth_index;
   wp2 = IF_index+Half_Bandwidth_index;
   ws2 = IF_index+Half_Bandwidth_index+Gap_index;
   *fcuts = [ws1 wp1 wp2 ws2]*fc/(Fflt/2);  % <2015-01-04>*
   fci = IF_index*fc;  % <2015-01-04>

2) NOTE, normalize filter
   hh = hh./max(hh); % normalize, <2015-01-04> 
   % rchn = rchn1*sqrt(Q); % HXA<2014-12-31>
   rchn = rchn1; % normalize fliter, HXA<2015-01-04>

3) Nfft is 128, Nfft*2*Q=256*Q, when Q is 16, total size is 4096

4) NOTE: spectrum, *fs/2
   f = (0:length(OFDM_IF)-1)/length(OFDM_IF)*fs/2; %<2015-01-04>
   plot(f/1e6, OFDM_IF);
   title(['Multi-IF',', IF_{index}: ', num2str(IF_index)])

5) NOTE: fftshift, wrong Spectrum, into 1:Nsd
   % r_Freq = r_Freq([(2:Nsd/2+1) (Nfft-Nsd/2+1:Nfft)]); 
   % careful of zero padding, No fftshift, <2015-01-04>
   r_Freq = r_Freq(1:Nsd); % No fftshift, <2015-01-04>

6) NOTE: zfltI1 = zfltI(n+1:end); % KEY: HXA<2014-12-31>, then r_down
   size decrease n/Q
   %% Removing cyclic prefix
   r_Parallel = r_down(Ncp+1:(Nfft+Ncp)); 

   % r_down  = rchn (1:160*Nu); % 130728
   % ofdm_chn = [ofdm_sig zeros(1,256*Nu-160*Nu)];	% 130728
   % ofdm_chn = [ofdm_sig];	% <2015-01-05>
   r_down  = rchn;  % <2015-01-05>


NOTE: OVERTIME@HOME, <2014-12-31 周三>
*** filter then downsample, KEY: delay by filter is n/2*2.
zfltI = filter(hh,1,Irx); % uses an order n FIR filte
zfltQ = filter(hh,1,Qrx);
zfltI1 = zfltI(n+1:end); % KEY: HXA<2014-12-31>
zfltQ1 = zfltQ(n+1:end); 
% 在滤波器设计中归一化频率是对fs/2来说的，即是对fs/2进行归一。如果是用弧度表示，
% 则是对pi进行归一。
% 昨天试了一下，现在才明白只要fs定的不一样，那么低通频率设置的也不一样！
% 低通截止频率是跟着fs变化的。
% % http://cn.mathworks.com/help/dsp/ref/adaptfilt.html
% % adaptfilt
% mu = 0.008;            % LMS step size.
% ha = adaptfilt.lms(32,mu);
% [y,e] = filter(ha,xmap,zmap);
% zmap = y;

rchn = downsample(zfltI1,Q)-1i*downsample(zfltQ1,Q); % HXA<2014-12-31>
rchn = rchn*sqrt(Q); % HXA<2014-12-31>

*** fir1 and kaiserord <2015-01-04 周日>
Fs     = 1.5*fc; % if Fs is 1.5fc, n is 94, stopband frequency
% Fs     = 1.2*fc; %  if Fs is 1.2fc, n is 235, stopband frequency


**  [#B] HXA_MFH150105.m
% % from HXA_OFDM_trx_BW_141230s2.m <2015-01-04 周日>
% from I_32CH_Part_1_version256QAM_2_Gen141226s4.m




* TODO [#B] MATLAB 						      :@work:

** Water filling
   1. MIMO_System.m
      1. WaterFilling_alg.m
      2. http://www.codeforge.cn/article/210144
** channel estimation
*** function ray = jakes(fm,fs,M,N_0,index) % Jakes Model of a Rayleigh fading channel
*** [#C] CE_MIMO.m
*** [#C] HXA_LTE_DS_OFDMs1.m from wenku, [2014-12-08 Mon]
    1. using preamble
*** [#D] MIMO2.m
*** pudn: ls_mmse_lmmse, MSE_compare.m
    1. [[http://www.pudn.com/downloads116/sourcecode/comm/detail495023.html][pudn: lmmse]]
    2. noise
       1. n1=ones(64,1);
       2. n1=n1*0.000000000000000001i;%加入复高斯白噪声
       3. noise=awgn(n1,SNR_send);
    3. DFT
       1. u=rand(64,64);
       2. F=fft(u)*inv(u);% DFT矩阵

*** 关于OFDM中MMSE信道估计算法的Matlab仿真, LmmseLsChannelEstimation_in_OFDM_Mfiles
    1. http://www.mscbsc.com/bbs/thread-184747-1-1.html
    2. h(lmmse)=Rhh*(Rhh+(beta/SNR)*I)^(-1)*h(ls)
    3. Jan-Jaap Van de Beek的On channel estimation in OFDM
    4. OFDM channel estimation by singular value decomposition
*** Channel estimation using LS and MMSE estimators, OFDM_CE_LS_MMSE_v3.m
    1. [[http://fr.mathworks.com/matlabcentral/fileexchange/46856-channel-estimation-using-ls-and-mmse-estimators][Mathworks: CE]]
*** Channel Estimation for OFDM systems, OFDM_Channel_estimators.m
    1. [[http://fr.mathworks.com/matlabcentral/fileexchange/41634-channel-estimation-for-ofdm-systems][Mathworks: CE]]
    2. % Ref: J J Van de Beek, "Synchronization and Channel Estimation
       in OFDM systems", Ph.D thesis,Sept. 1998 

*** MIMO_OFDM
    1. [[http://www.pudn.com/downloads52/doc/comm/detail182554.html][pudn:mimo]]
    2. pdf: Project Report 359: Adaptive Loading in MIMO/OFDM Systems

*** Blind Channel estimation for MIMO systems using Linear Space time codes
    1. [[fr.mathworks.com/matlabcentral/fileexchange/25817-blind-channel-estimation-for-mimo-systems-using-linear-space-time-codes][CE:STC]]

** EQU

*** ZF_mimo.m

*** vblast.m

** 基带信号眼图
   - Note taken on [2015-07-08 Wed 13:44] \\
     just a note
  1) http://wenku.baidu.com/view/2a97414bbe1e650e52ea99a5.html

** DBPSK

*** ipD = mod(filter(1,[1 -1],ip),2); % %differential encoding y[n]=y[n-1]+x[n]
http://www.dsplog.com/2007/09/30/coherent-demodulation-of-dbpsk/
ipDHat_coh = real(y) > 0; % coherent demodulation
ipHat_coh = mod(filter([1 -1],1,ipDHat_coh),2); %differential decoding

** Sibelobe suppresion

*** FFT and Spectral Leakage
 1) http://www.gaussianwaves.com/2011/01/fft-and-spectral-leakage-2/

*** [#C] ACE, constellation expansion, Active Constellation Extension
**** [#C] OFDMusingACE.m, http://www.readsourcecode.com/read76/sourcecode/app/detail289886.html
**** ofdmace.m

*** Tone_Reservation, similar as clipping
 1) http://www.pudn.com/downloads190/sourcecode/windows/detail895470.html
 2) 该算法也叫预留子载波法，就是预留出一些子载波，不用来传输数据，专门
    用作消峰处理。可见，该算法是以牺牲数据的传输速率来实现峰均功率比的
    降低


** CE-OFDM, Constant envelop-OFDM (CE-OFDM), Clustered OFDM,


** MIMO

*** BD, blcok_diagonalized_ci.m

  1) http://www.codebus.net/d-DTd4.html
  2) 可对角化矩阵
  3) P 是由这些特征向量作为纵列的矩阵
*** STTC

**** ENCODE 
  1) Convolution  encoders  with  the  same  structure  but  with
     different weighting coefficients are assigned to transmitting
     multiple branches in STTC

*** SFBC, FD, frequency diversity

**** ostbc_ber.m
  1) http://www.eeworm.com/read/361455/7149587

**** SFBC-OFDM
  1) http://www.pudn.com/downloads127/sourcecode/book/detail540255.html
**** OSTBC_ber
  1) http://readsourcecode.com/read130/sourcecode/others/detail554438.html



*** SM

**** [#C] from mathwork
  1) http://fr.mathworks.com/help/comm/examples/spatial-multiplexing.html

*** [#C] STBC, alamouti_stbcs1.m

**** stbc_tx.m and stbc_rx.m

**** http://www.dsplog.com/2008/10/16/alamouti-stbc/
*** space-time trellis coding (STTC), STTC-OFDM, stcc_ofdm_freq.m
  1) http://www.pudn.com/downloads108/sourcecode/math/detail445326.html

** LDPC

*** LDPC_demo.m

*** http://fr.mathworks.com/matlabcentral/fileexchange/25293-matlab-for-digital-communication/content//LDPC_demo.m

** OQPSK

*** http://www.codeforge.cn/read/142158/oqpsk.m__html

*** matlab
 1) %*************************** OQPSK Modulation ******************************** 
  
    [ich,qch]=qpskmod(data1,1,nd,ml);
    [ich1,qch1]=compoversamp(ich,qch,length(ich),IPOINT);
    ich21=[ich1 zeros(1,IPOINT/2)];
    qch21=[zeros(1,IPOINT/2) qch1];
    [ich2, qch2]=compconv(ich21,qch21,xh); 

** star-QAM

 1) http://stackoverflow.com/questions/11242788/star-16-qam-modulator-and-demodulator-matlab
 2) % Define mapping table applying Gray mapping
mappingTable(1) = r1 * exp(1i* 0);
mappingTable(2) = r1 * exp(1i* pi/4);
mappingTable(3) = r1 * exp(1i* 3*pi/4);
mappingTable(4) = r1 * exp(1i* pi/2);
mappingTable(5) = r1 * exp(1i* 7*pi/4);
mappingTable(6) = r1 * exp(1i* 3*pi/2);
mappingTable(7) = r1 * exp(1i* pi);
mappingTable(8) = r1 * exp(1i* 5*pi/4);
mappingTable(9:16) = mappingTable(1:8) ./ r1 .* r2;
** Polyphase filters for interpolation
*** Lecture 6, Multirate Signal Processing,Windows, Sampling
 1) https://www.tu-ilmenau.de/fileadmin/media/mt/lehre/ma_mt/multirate_signal_processing/Vorlesung/06_12-04-25MultirateSigProcWindowSampling.pdf
*** Window Functions – An Analysis
 1) http://www.gaussianwaves.com/2011/02/window-functions-an-analysis/
*** dspblog
  1) http://www.dsplog.com/2007/05/12/polyphase-filters-for-interpolation/
*** http://web.mit.edu/1.130/
*** http://m2matlabdb.ma.tum.de/download.jsp?MC_ID=12&MP_ID=62

** UFMC UFMC OFDM 收发信机链
 1) http://www.codeforge.cn/article/241528

*** [#C] UFMC_OFDM_TransceiverChain_0.m, ALU Stuttgart
 1) http://www.5gnow.eu/?page_id=424 

** [#C] fbmc

*** Understanding_5G

*** [#C] FBMC_QAM.m
 1) http://www.codeforge.com/read/227159/FBMCQAM.m__html

*** OQAM_OFDM_Perfect.m
 1) http://www.codeforge.com/read/231097/OQAM_OFDM_Perfect.m__html
 2) 多径衰落信道：IEEE802.22

*** FBMCOQAM.m
 1) http://www.codeforge.cn/read/223808/FBMCOQAM.m__html
 2) %过多项结构
    outf1=zeros(N+K-1,M);
    for ii=1:M
    outf1(:,ii)=conv(h1(ii,:),signalIFFT(:,ii));
    end

*** [#B] OQAM_IFFT.m
 1) http://www.codeforge.cn/read/240589/OQAM_IFFT.m__html
 2)     % signal_real=real(signal);
    % signal_imag=imag(signal);
    % signal_new(:,1:2:2*N_symbol-1)=signal_real;
    % signal_new(:,2:2:2*N_symbol)=signal_imag;

*** [#C] Main_FBMC.m to FBMC150511.m to FBMC_noise.m
 1) http://www.codeforge.cn/read/228180/Main_FBMC.m__html
 2) http://www.codeforge.com/read/216581/FBMC_Noise.m__html
 3)  according to  report :PHYDYAS PHYsical layer for DYnamic AccesS
     and cognitive radio%    "Prototype filter and filter bank
     structure"


**** FBMC: OQAM-Pre-Processing
http://fr.mathworks.com/matlabcentral/fileexchange/42264-fbmc--oqam-pre-processing/content/OQAM_preprocessing.zip

**** FBMC: OQAM-Post-Processing
http://fr.mathworks.com/matlabcentral/fileexchange/42265-fbmc--oqam-post-processing


*** [#C] FBMC Modulation / Demodulation,  to FBMC_ueasy.m, UltraEasyFBMC.m from mathworks
  1) FBMC_150508.m
  2) % OQAM Modulator
    if rem(ntrame,2)==1
     s(1:2:N,ntrame)=sign(randn(N/2,1));
     s(2:2:N,ntrame)=j*sign(randn(N/2,1));
    else
     s(1:2:N,ntrame)=j*sign(randn(N/2,1));
     s(2:2:N,ntrame)=sign(randn(N/2,1));
    end

*** FBMC_OFDM_Subcarriers.m
http://www.mathworks.com/matlabcentral/fileexchange/42272-fbmc-ofdm--sub-channels-comparison/content//FBMC_OFDM_Subcarriers.m

*** FBMC_OFDM_Prototype.m from mathworks

** [#C] OFDMwithwindowing, OFDMdemo.m
 1) http://www.pudn.com/downloads186/sourcecode/app/detail871527.html
 2) http://read.pudn.com/downloads186/sourcecode/app/871527/OFDMwithwindowing/OFDMdemo.m__.htm
** fsk
 1) y = fskmod(x,M,freqsep,nsamp,Fs);
 2) http://deepeshrawat987.blogspot.fr/2013/09/matlab-code-for-digital-modulation.html
    1)     if x(i)==1
       ask=sin(2*pi*f*t);
       fsk=sin(2*pi*f*t);
       psk=sin(2*pi*f*t);
    else
        ask=0;
        fsk=sin(2*pi*f2*t);
        psk=sin(2*pi*f*t+pi);
    end

** sc_fde_mimo_preq.m,  SC-FDE-MIMO pre-equalization system
 1) link: http://matlab-code-by-wayne.googlecode.com/svn/tags/THP/sc_fde_mimo_preq.m
 2) sc_fde

** precoding and equalization

*** Zero Forcing equalization
% Matlab code for using Toeplitz matrix for convolution
Figure: Frequency response of the channel and the equalizer
http://www.dsplog.com/2009/11/29/ber-bpsk-isi-channel-zero-forcing-equalization/



*** TF, transversal filter
  1. The transversal adaptive filter can be split into two main parts, the filter part and the update part. 

*** Transmit beamforming and precoding
  1) http://www.dsplog.com/2009/04/13/transmit-beamforming/
  2) % Channel and noise Noise addition
     1) hEff = h.*exp(-j*angle(h));
  3) 首先，如楼上说的，预编码用于闭环系统中，以下行为例，要实现下行预编
     码，需要上行相关的反馈信息。至于定义，现在给的都很模糊，主要就是发
     送端利用反馈得到的信息，对信道矩阵做一定的处理，使收端得到更高的信
     噪比。如下式：r ＝ HWx+nr为接收信号，H为信道，n为噪声，这里的矩阵W
     就是对信道H进行预编码处理。而W的获取，是通过信号接收端反馈的信息去
     得到的。

** [#C] adaptive(LMS and RLS(DFE)), DSP_ihsantest3.m
 1) %LMS Algorithm

** PAM4
 1) http://www.dsplog.com/2007/10/07/symbol-error-rate-for-pam/
 2) alpha4pam = [-3 -1 1 3]; % 4-PAM alphabets
Es_N0_dB = [-3:20]; % multiple Eb/N0 values
ipHat = zeros(1,N);
for ii = 1:length(Es_N0_dB)
ip = randsrc(1,N,alpha4pam);
** [#B] Simulation of Digital Communication Systems Using Matlab
*** https://www.ptt.cc/bbs/MATLAB/index.html
** hierarchy modulation

*** Vectorial superposition, layer 1 and 2
 1) Modulation with QPSK Base Layer and QPSK Enhancement Layer 
 2) http://ecee.colorado.edu/~ecen4242/UMB/modulate.htm
***  dvb-t
1) You could do it via indexing.

2) dvb-t modulation hierarchy  matlab
*** gray code, op = bitxor(ip,floor(ip/2))
 1) In a digital communication system, if the constellation symbols
    are Gray encoded, then the bit pattern representing the adjacent
    constellation symbols differ by only one bit.



** [#C] CFO


*** CFO_estimation.m from Matlab_MIMO
  1) function CFO_est = CFO_CP(y,Nfft,Ncp) nn=1:Ncp; CFO_est = angle(y(nn+Nfft)*y(nn)')/(2*pi); 

*** edboard

 1) http://www.edaboard.com/thread133625.html
 2) Like I can see estimate frequency not correctly:
    fd - sample frequency
    Bconj=Bm(2:end).*conj(Bm(1:end-1)); %frequency offset algorithm
    foffest=fd*mean(angle(Bconj))/(2*pi) %estimate frequency offset

*** [#C] CFO in dspblog, DSP_frequencyoffsetestimateofdm.m
 1)  nFFTSize = 64; % Must 64, [2015-06-01]
 2) Frequency offset estimation using 802.11a short preamble
    1) Given that short preamble is perodic with \delta t
    2) Taking angle() of both sides of the equation
    3) ytDelayBuffer = zeros(1,0.8*fsMHz);
       1) Frequency offset estimation in 802.11a OFDM preamble From
          the IEEE 802.11a specifications (Sec 17.3.3), it can be
          observed  that each OFDM packet has a preamble structure
          formed using 10 short  preambles of duration each. This
          short preamble is constructed by  defining 12 subcarriers
          only (out of the available 52 subcarriers) where the
          modulation of individual subcarriers ensure a low peak to
          average power ratio.
    4) 根据DFT变换的性质，频偏相当于在时域上有一个随着时间变化的相移
 3) http://www.dsplog.com/2008/03/03/frequency-offset-estimation-using-80211a-short-preamble/

*** CFO
  1) http://www.codeforge.com/read/162427/CFOsimutemp2varying.m__html
  2) http://www.codeforge.com/article/162427

*** ML Estimation of Timing and CFO in OFDM systems from mathworks
 1) by Hiren Gami
 2) This estimation method is based on well known paper. J.J. van de
    Beek, M. Sandell, and P.O. BÄorjesson, `ML Estimation of Time and
    Frequency O®set in OFDM Systems', IEEE Transactions on Signal
    Processing, vol. 45, no. 7, pp. 1800{1805, July 1997.
*** Frequency offset estimation for OFDM in MATLAB
 1) http://www.rfwireless-world.com/source-code/MATLAB/frequency-offset-estimation-correction-matlab-code.html
 2) code
    1) for m=0:128
    2) theta(m+1) =
       angle(sh_dat(65+m:128+m)*sh_dat(1+m:64+m)')/(2*pi);
    3) end
    4) theta = mean(theta);

** [#C] MS_ml.m
   1. http://read.pudn.com/downloads77/sourcecode/book/291233/zuidasiran.m__.htm
   2. http://www.pudn.com/downloads112/sourcecode/book/detail466781.html


** [#C] MS_MLE.m
http://www.gaussianwaves.com/2012/10/likelihood-function-and-maximum-likelihood-estimation-mle/
** ML, main_script_MLE.m
http://www.pudn.com/downloads620/sourcecode/windows/csharp/detail2525314.html
** [#C] cdma, compgroups.net/comp.dsp/

http://compgroups.net/comp.soft-sys.matlab/matlab-code-required-for-cdma-ds-cdma-mu/2972717

http://compgroups.net/comp.dsp/mc-cdma-simulation-using-matlab/1177381


** GFSK
*** bluetooth藍芽 GFSK 調變與解調, bluetooth.m

% 經由Gaussian filter濾波後之基頻帶訊號：
uf=fft(Di); 
uff=uf.*gau; 
Di=real(ifft(uff));
Dio=Di; 
Di=Di/dr*pi*h; 
U0=0;
http://www.ilovematlab.cn/thread-13707-1-1.html

*** script_fsk_bit_error_rate.m
freqR = kron(freqM,ones(1,T)); % repeating

op1 = conv(y, sqrt(2/T)*cos(2*pi*1*t)); % correlating with frequency 1
    op2 = conv(y, sqrt(2/T)*cos(2*pi*2*t)); % correlating with frequency 2
    
    % demodulation
    ipHat = [real(op1(T+1:T:end)) < real(op2(T+1:T:end))]; 
http://www.dsplog.com/db-install/wp-content/uploads/2008/06/script_fsk_bit_error_rate.m

*** script_ber_msk_awgn.m
 % MSK transmit waveform
    xt = 1/sqrt(T)*[ai.*ct + j*aq.*st];
http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/


** EVM_with_phase_noise.m, dspblog, theoretical EVM
http://www.dsplog.com/2012/07/09/evm-phase-noise/

** [#C] Correlative Coding – Modified Duobinary Signaling
[2015-03-30 Mon]
www.gaussianwaves.com/tag/matlab-code/page/3/

** [#C] Duobinary_EncDec.m, 2-tap-FIR


** DSP_duobinary.m
 1) http://www.mathworks.com/matlabcentral/fileexchange/7360-duobinary-signaling-encoder
** [#C] FMT, DSP_DMT.m, filter bank multicarrier, filtered multitone (FMT)
*** [#C] DMT.m DMT matlab, from mathworks
**** code
  1) http://www.mathworks.com/matlabcentral/fileexchange/9437-discrete-multitone-modulation-simulation/content/MT.m
  2) x_mod=ifft([1 complex_symbol 1 fliplr(conj(complex_symbol))],2*N);

**** channel, h
  1) y=conv(x,h); % received data stream.
  2) x_recd=fft(y_mod)./fft(h,2*N);
*** difference
  1) 与OFDM 不同，FMT 信号不包含循环前缀，其信号与信道之间并不满足循环卷积
  2) 与OFDM 类似，FMT也可采用IFFT/FFT 结构来实现

** filter bank based multicarrier (FBMC), not yet


**  [#B] SCFDMA, SCIFDMA,-SCLFDMA

*** [#A] edaboard, dspblog, dsprelated, codeforge, guassianwaves      :@tool:
Simulation of OFDM system in Matlab – BER Vs Eb/N0 for OFDM in AWGN channel
http://www.gaussianwaves.com/2011/07/simulation-of-ofdm-system-in-matlab-ber-vs-ebn0-for-ofdm-in-awgn-channel/

**** SC-FDMA uses a smaller DFT ahead of a big DFT

     - http://www.edaboard.com/thread148621.html
     - --src-->modulator-->ofdma mapper-->OFDMA symbol
--src-->modulator-->dft-->ofdma mapper--->DFT-spread-OFDMA(SC-FDMA)
*** DONE [#B] [key] scfdma.m
[2014-12-10 周三]
    - State "DONE"       from "TODO"       [2015-01-12 周一 10:10]
    - H_eff = H_channel(1+SP.subband:Q:numSymbols); % EQUALIZATION, /141205
    - http://www.pudn.com/downloads126/sourcecode/math/detail535799.html
**** [#B] [key], scfdma141205.m, success, [2014-12-12 周五]
 H_eff = H_channel(1+SC.subband:Q:NFFT); % 1*inputBlockSize, EQUALIZATION, <2014-12-05>
        %         if SC.equalizerType == 'ZERO'
        %             Y_ifdma = Y_ifdma./H_eff;
        %         elseif SC.equalizerType == 'MMSE'
        %             C = conj(H_eff)./(conj(H_eff).*H_eff + 10^(-SNR(n)/10));
        %             Y_ifdma = Y_ifdma.*C;
        %         end

% SC.FFTsize = 128;
% Nsd = 32;
% NFFT = SC.FFTsize;
% SC.CPsize = Nsd/4; 

***** ML.scfdma.pdf

**** key, runCCDF141212.m

****  LTE OFDM, 15-kHz, FFT size-->sampling rate, data size-->BW
 Overview of LTE
| Spectrum Allocation  | 2.5-MHz  | 5-MHz      | 10-MHz    |    15-MHz | 20-MHz   |
|----------------------+----------+------------+-----------+-----------+----------|
| Frame duration       | <        | 10-ms      |           |           | >        |
| Subframe duration    | <        |            | 1-ms      |           | >        |
| Symbol Duration      | <        | 66.7 \mu s |           |           | >        |
| subcarrier spacing   | <15-kHz  |            |           |           | >        |
|----------------------+----------+------------+-----------+-----------+----------|
| Sampling frequency   | 3.84-MHz | 7.68-MHz   | 15.36-MHz | 23.04-MHz | 30.72MHz |
|----------------------+----------+------------+-----------+-----------+----------|
| FFT size             | 256      | 512        | 1024      |      1536 | 2048     |
|----------------------+----------+------------+-----------+-----------+----------|
| number of Subcarrier | 150      | 300        | 600       |       900 | 1200     |
Number of subcarrier 
In addition to this the subcarriers spacing is 15 kHz, i.e. the LTE
subcarriers are spaced 15 kHz apart from each other. 
 To maintain orthogonality, this gives a symbol rate of 1 / 15 kHz =
 of 66.7 µs.
 BW = FFT Size x Symbol Rate 
    1.4 MHz    3 MHz    5 MHz    10 MHz    15 MHz    20 MHz



***** paprOFDMA.m

***** paprscfdma.m

*** [#B] [key] ofdm9263.m,

**** @key: papr9263.m,
xbi_rs         = reshape(xbi,k,length(xbi)/k); % HXA, <2014-12-12>
[numErrors,BER(ii)] = biterr(zbiall, xbiall); % HXA, <2014-12-12>


*** paprSCFDMA()  from mathworks <2014-12-09>

Simple Single Carrier FDMA (SC-FDMA) Simulator
http://www.mathworks.com/matlabcentral/fileexchange/20454-simple-single-carrier-fdma--sc-fdma--simulator/content/papr/paprSCFDMA.m

**** DFDMA, hlist CCDF

**** psFilter = rcPulse(Ts, Nos, rolloffFactor); <2014-12-12>

**** Q_tilda = 31; % Bandwidth spreading factor of DFDMA. Q_tilda < Q.
% Plot CCDF.
[N,X] = hist(papr, 100);

% Subcarrier mapping.
    if subcarrierMapping == 'IFDMA'
        Y(1:Q:totalSubcarriers) = X;
    elseif subcarrierMapping == 'LFDMA'
        Y(1:numSymbols) = X;
    elseif subcarrierMapping == 'DFDMA'
        Y(1:Q_tilda:Q_tilda*numSymbols) = X;
    end

*** Simple Single Carrier FDMA (SC-FDMA) Simulator, matlabcentral

**** http://www.mathworks.com/matlabcentral/fileexchange/20454-simple-single-carrier-fdma--sc-fdma--simulator/content/papr/paprSCFDMA.m

*** scofdma.m, error, [2014-12-22 Mon]
OFDMA & SC-FDMA performance analysis 

**  IFDMA, BIFDMA
*** [#B] my_ifdma.m from ilovematlab
[2015-03-10 Tue]
http://www.ilovematlab.cn/thread-50594-1-1.html

*** Block-Interleaved Frequency Division Multiple Access
Block-Interleaved Frequency Division Multiple Access and its
Application in the Uplink of Future Mobile Radio Systems
- an algorithm for B-IFDMA signal generation in time domain providing a
low computational complexity,

*** Block Interleaved Frequency Division Multiple Access for Power Efficiency, Robustness, Flexibility and Scalability
 B-IFDMA is also a generalization
of Localized Frequency Division Multiple Access (LFDMA)
[10], also denoted Localized DFTS-OFDM or SC-FDMA with
localized mapping, [8], [9]. The IFDMA scheme has been con-
sidered in the uplink of the 3GPP Long Term Evolution (LTE)
standard, but LFDMA was adopted.

*** codeforge, IFDMA.m
http://www.codeforge.com/read/116422/IFDMA.m__html

symbals.m
% click here to download the whole source code package.
% http://www.codeforge.com/read/116422/symbals.m__html

*** IFDMA dsprelated, S(2:2:end) = fft(symbolsUser2);
http://www.dsprelated.com/showmessage/114499/1.php


**  [#B] key matlab ls

*** [#C] MS_LMS_matlab.m
    1. for i=(k+1):N
      XN=xn((i-k+1):(i));
      y(i)= w*XN';
      e(i) = s(i)-y(i);
      w = w+u*e(i)*XN;
      %         w(i+1)= w(i)+ u*e(i)*XN; end
    2. % y = y(k:end);
    3. y = y(k+2:end);  % must have a smoothing length, [2015-07-02]
    4. y_hat = sign(real(y))+sqrt(-1)*sign(imag(y));  % perform symbol detection

*** [#A] DSP_rcosFlts2.m , MS_tdmsim.m, LTE_DS_OFDMs1.m, and MS_FDM8x1.m
<2015-01-04 周日>
**** DSP_DTMF.m, and DSP_commdoc_mod.m, DSP_fwht.m
MS_tdmsim.m
dscp_str
****  LTE_DS_OFDMs1.m
% 训练符号频域数据，采用802.11a中的长训练符号数据


*** [#A] @key: @tdd, MS_tdmsim.m by Deepak,  k is multiplexing, k=k+1 inside n, n is 5, r is 8, k is 41
**** @mathworks, MS_TDM.m, reshape, parallel2serial
     1. http://www.mathworks.com/matlabcentral/fileexchange/28422-time-division-multiplexing-tdm-/content//TDM.m
#+BEGIN_SRC octave
for i=1:l1
    sig(1,i)=sig1(i);                        % Making Both row vector to a matrix
    sig(2,i)=sig2(i);
end

% MUX, TDM of both quantize signal
tdmsig=reshape(sig,1,2*l1)

% Demultiplexing of TDM Signal
demux=reshape(tdmsig,2,l1);
for i=1:l1
    sig3(i)=demux(1,i);                    % Converting The matrix into row vectors
    sig4(i)=demux(2,i);
end
#+END_SRC
**** by Deepak Kumar Rout, from Matlab Central
#+BEGIN_SRC octave
%multiplexed signal
    figure
    k=1; % i is mux, j is length, [2015-07-24]
    for i=1:n
         for j=1:r
               m(1,k)=a1(i,j);
               j=j+1;
              k=k+1;
         end
    i=i+1;
    end
    stem(m);title('Multiplexed Signal');
#+END_SRC
#+BEGIN_SRC octave
%demultiplexed signal
figure
k=1;
for i=1:n
    for j=1:r
        t(1,j)=m(1,k);
        d(i,j)=t(1,j);
        j=j+1;
        k=k+1;
    end
    subplot(n,1,i);
    stem(t);title('Received Signal');
end

#+END_SRC


*** [#B] MS_LMS_matlab.m, <2015-01-08 Thu>
1)  w=w+u*e(i)*XN;
    %并给出均方误差曲线，假设抽头个数为k，数据长度为N
     %设置初值
    y=zeros(1,N); %输出信号y
    y(1:k)=xn(1:k); %将输入信号xn的前k个值作为输出y的前k个值
    w=zeros(1,k); %设置抽头加权初值xn
    e=zeros(1,N); %误差信号
    %用LMS算法迭代滤波
    for i=(k+1):N
        XN=xn((i-k+1):(i));
        y(i)=w*XN';
        e(i)=s(i)-y(i);
        w=w+u*e(i)*XN;
    end

*** @key:: FM_mod.m, by Deepak, parfor and fmmod
ch_op=awgn(sum(y),0,'measured');
% Generate the modulated signal, from Matlab Central
parfor i=1:nos
    y(i,:)=fmmod(m(i,:),cfreq(1,i),10*cfreq(1,i),freqdev);
end



*** [#B] @key:: CA8x1.m, bi2map.m, map2bi.m
10.5dB as CCDF is 1e-3
xbiall, zbiall
xifft-->xtx
yrx-->yfft
PAPR(kk) = papr8x1(xtx); % kk at least 1e3, MUST put here, HXA<2014-12-25>
 zmap_in = EstSymbols_ifdma;
        zmap = zmap_in(1:Nsd); % be careful, HXA<2014-12-25>

*** SLM, slm_modified.m, and SLMsuanfa.m

**** KEY: *SLMsuanfa.m*, repmat, hlist into ecdf
X(2:N,:) = repmat(X(1,:),N-1,1).*Phase_Rot;  % Phase roated Frequency domain signal
[cdf1, PAPR1] = ecdf(PAPR_Orignal);
 ecdf: empirical cumulative distribution function (cdf)

**** KEY: Baher Mohammed, <2014-12-23>
selective-mapping-with-phase-rotation
http://www.mathworks.com/matlabcentral/fileexchange/authors/103379

**** script_papr_ofdm_tgn_j_rotation.m
KEY:  j*ipModBPSK
% Assigning modulated symbols to subcarriers 
xBPSK1F = [zeros(nSym,6) ipModBPSK(:,[1:nDSC/2]) zeros(nSym,3)...
 ipModBPSK(:,[nDSC/2+1:nDSC]) zeros(nSym,5)] ; % without j rotation
xBPSK2F = [zeros(nSym,6) ipModBPSK(:,[1:nDSC/2]) zeros(nSym,3)...
 j*ipModBPSK(:,[nDSC/2+1:nDSC]) zeros(nSym,5)] ; % with j rotation

Trying out PAPR reduction for OFDM by multiplication with j
http://www.dsplog.com/2008/07/02/ofdm-papr-reduction-multiplication-by-j/


*** [#B] @key:: ifdma8x1.m
from scfdma8x1.m 
NOTE: 
1) fft then see spectrum, fft then FDE, ifft then PAPR.
2) ifft then BER is large, error, changed into fft(RX ifft),  all BERs are 0. 
case: ifft, No fft before ifft
BER_ifdma =
    0.4510
    0.4363
    0.4237
    0.4039
    0.3860
    0.3616

 %         inputSymbols_freq = fft(inputSymbols);  % inputSymbols=Nsd, <2014-12-08>
        inputSymbols_freq = (inputSymbols);  % HXA,<2014-12-22>
        inputSamples_ifdmaQ(1+OFDM.subband:Q:Nfft) = inputSymbols_freq;
        %         inputSamples_ifdma= IFDMA(inputSymbols,Q,Nsd,1);  % IFDMA, HXA, <2014-12-22>
        %         x1=IFDMA(x,N/para,para,nd);  % IFDMA before, HXA, <2014-12-22>
        %         inputSamples_ifdma = ifft(inputSamples_ifdmaQ);
        inputSamples_ifdma = fft(inputSamples_ifdmaQ)


*** [#B] @key: SLMsuanfa.m
paper: bauml1996reducing
x = ifft(X,[],2);                            % Time domain signal
   % into inputSamples_ifdmaQ, HXA<2014-12-23>, NFFT=SC.FFTsize, <2014-12-08>
        % Phase_Set = [1 -1]; % from SLMsuanfa.m, HXA<2014-12-23>
% Phase_Rot = Phase_Set(Index(2:N,:));
        % X(2:N,:) = repmat(X(1,:),N-1,1).*Phase_Rot;  % Phase roated
        Frequency domain signal

**** slm_16qam.m
http://slm_16qam.m/

http://www.pudn.com/downloads400/sourcecode/windows/comm/detail1708404.html
*** PTS, partial_transmit_sequence.m
 final_signal=B(k,1)*Pt1+B(k,2)*Pt2+B(k,3)*Pt3+B(k,4)*Pt4;
http://fr.mathworks.com/matlabcentral/fileexchange/33397-partial-transmit-sequence/content/partial_transmit_sequence.m

*** OFDM_IF_TX.m from GZS FW: ofdm 

*** paprofdma.m, ifft
    numSymbols = totalSubcarriers/4; % Data block size.
    Nos = 4; % Oversampling factor.
    t = [0:Ts/Nos:Nsub*Ts];
    Fsub = [0:Nsub-1]*Fs/Nsub; % Subcarrier spacing.
    for k = 1:numSymbols,
        y= y + data(k)*exp(j*2*pi*Fsub(k)*t);
    end
   
*** OFDM_trx_BW_130728.m <2014-12-11>

*** Simple Single Carrier FDMA (SC-FDMA) Simulator 
from mathwork

**** ofdm(SP).m  <2014-12-12>

**** paprOFDMA().m
     % OFDM modulation.
     y = 0;
     for k = 1:numSymbols,
         y= y + data(k)*exp(j*2*pi*Fsub(k)*t);
     end

**** runSimSCFDE()

***** function SER = scfde(SP) <2014-12-16>
by Hyung Myung
25 Jun 2008 (Updated 27 Jun 2008)
Simple link level and PAPR simulators for SC-FDMA system.
http://fr.mathworks.com/matlabcentral/fileexchange/20454-simple-single-carrier-fdma--sc-fdma--simulator/content//scfde/scfde.m

***** [#A] key, scfdma.m, equa, 
 line 46, after fft and before ifft
H_eff = H_channel(1+SP.subband:Q:numSymbols); 


*** [#A] OFDM_tx130907.m from OFDM_tx0907code.m [2014-12-16 周二]

**  [#B] key matlab code

*** [[http://en.verysource.com/][ln: verysource]]

*** show date, date

*** subfuntion, ode_ex2.m
[t,y]=ode45(@vdpol,trange,y0,options);
function vdpol


*** [#A] key save filename, all data, <2014-12-12> 

*** tic and toc [2014-12-12 Fri]

*** pilot EQUA OFDMChEstAlgLSE.m, Ysym./fft(hHat,N)
OFDM LSE Channel Estimation
 least-squares error (LSE)
http://fr.mathworks.com/matlabcentral/fileexchange/13127-ofdm-lse-channel-estimation/content//OFDMChEstAlgLSE.m
% Pilot Location and strength
Ip = [1:pilotInterval:N];       % location of pilots
       hHat = G*Ypilot;    % estimated channel coefficient in time domain
        hHat = Ypilot./Spilot;    % almost right, HXA, <2014-12-11>
        estimated channel coefficient in time domain

        TxDataBit   = qamdemod(TxDataMod./(fft(hHat,N)),M);

*** ZF, noise is enhanced
% Zero-forcing equalizer multiplies  Y(f) by inv(H(f))
% inv(H(f))Y(f)=X(f)+inv(H(f))Z(f)
% thus we essancially get an ISI free channel.
% The drawback is that noise is enhance


** Study matlab study other
*** matlab study
http://homepages.ulb.ac.be/~dgonze/INFO/matlab.html
*** CA, carrier_aggregation.m
http://fr.mathworks.com/help/lte/examples/rmvd_matlablink__e111a47e26e943985a16d0b76b7fc6eb.html
*** DSP_ofdm1024.m
% Convert the phase to a complex number
[X,Y] = pol2cart(carrier_matrix, ones(size(carrier_matrix,1),size(carrier_matrix,2)));
complex_carrier_matrix = complex(X,Y);
*** Puncturing
% Puncturing
    	msg_bits_out(4:6:end)=[];	% puncturing 1/2 to 3/4	 
    	msg_bits_out(4:5:end)=[];	% puncturing 1/2 to 3/4
http://fr.mathworks.com/matlabcentral/answers/14672-this-program-is-for-random-data-followed-by-its-fec-coding-dpsk-modulation-for-ofdm-transmission

*** Sync
**** MS_timing_syn.m, Gardner Timing Recovery
http://read.pudn.com/downloads114/sourcecode/others/481138/timing_syn_Gardner.m__.htm

**** [#B] QPSKTimingRecovery.m
http://fr.mathworks.com/help/comm/examples/qpsk-transmitter-and-receiver.html
**** [#B] MS_ml.m
http://read.pudn.com/downloads112/sourcecode/book/466781/ml/mlmethod.m__.htm
**** MS_ML_cp.m

*** MS_precoding.m
<2015-01-09 周五>
t=nFFT/4;
for m=1:nFFT
    for q=1:nFFT
        if (m==q)&(m==t)
            W(m,q)=2;
        elseif m==q
            W(m,q)=1;
        elseif q==t
            W(m,q)=1;
        else
            W(m,q)=0;
        end
    end
end

ipModd=(ipMod*W);


*** TDD, [2015-01-13 Tue]

**** LTE_common_gen_Synchronization_Signal.m, PSS, not yet

**** PSS_corr.m, not yet


* [#B] matlab book, MIMO-OFDM, \cite{cho2010mimo}, [[papers:cho2010mimo][cho2010mimo-paper]]

** [#D] \cite{chu2011fpga}, FPGA Prototyping with Verilog examples code, verilog
   1. examples
   2. Pong P. Chu, Cleveland State University
*** 12 Xilinx Spartan3 Specific Memory
   1. 12.4 HDL templates for memory inference
      1. 12.4.2 Dual-port RAM
   2. 13.5.1 Dual-port RAM implementation, pp365
** 基于XILINX FPGA的OFDM通信系统基带设计, \cite{shi2009xilinx}

*** [#D] 4.6 Data 符号调制, pp75

**** 4.6.4 模块实现
     1. 数据格式为8位, 6位为小数，不解
*** DONE 大量FPGA的verilog源代码
    CLOSED: [2015-08-11 Tue 15:42]
    - State "DONE"       from ""           [2015-08-11 Tue 15:42]

*** 无线通信的matlab和fpga实现

*** 无线通信FPGA设计, not yet
    1. http://forum.eepw.com.cn/thread/155177/1

*** 数字调制解调技术的MATLAB与FPGA实现 

** [#C] @key: Understanding LTE with MATLAB, \cite{zarrinkoub2014understanding}, [[papers:zarrinkoub2014understanding][zarrinkoub2014understanding-paper]]

*** @note:
   1. @key: beamforming or Tx Diversity
   2. @func: CQIselection and CQI2indexMCS, sinr2MCS
      1. sinr=10*log10(var(modOut)./var(error));
   3. @key: missing *@func: DLSCH*, *prm: parameter*
   4. pp39, Figure 2.15 MIMO beam forming, multi ants for 1 UE
   5. pp42, Figure 2.16 Signal processing chain of downlink DLSCH and PDSCH
   6. Channel Quality Indicator(CQI), Precoder Matrix Indicator (PMI), and Rank Indicator (RI) measurements
   7. MIMO (layer mapping and precoding), and OFDM (RE mapping) 
   8. Understanding LTE with MATLAB: From Mathematical Modeling to Simulation and Prototyping
   9. @date: [2015-07-22 Wed]
   10. [[http://emuch.net/html/201506/9023166.html][emuch: ml_LTE]]
   11. [[https://www.mathworks.com/examples/lte-system/4669-comp-dynamic-point-selection-with-multiple-csi-processes][ml_comp]]
   12. http://www.bb.la/D5C920D1A47D64F702A70901DE360365397198A6.html
*** Beamforming for MIMO-OFDM Systems
    1. http://cn.mathworks.com/help/phased/examples/beamforming-for-mimo-ofdm-systems.html
    2. Meanwhile, the array is also steered toward a given steering
       angle, so the total weights are a combination of both precoding
       and the steering weights.
    3. weight = wT.* wR;
    4. beamforming is a method of concentrating radio frequency (RF)
       energy in order to improve the signal 
*** 5. OFDM
**** 5.18.1 The SISO Case, pp150
***** 5.18.1.1 Structure of the Transceiver Model
      1. %% pp151, no function prmsDLSCH in function commlteSISO_initialize
      2. MATLAB script: commlteSISO

**** 5.7 LTE Resource Grid
     1. Physical Broadcast Channels (PBCHs)
     2. the placement and resolution of pilot signals (CSR) along both axes of the resource grid
**** 5.8 Configuring the Resource Grid
*** 6. MIMO
**** 6.7.5.2 Precoding, pp226
     1. function [out, Wn] = SpatialMuxPrecoder(in, prmLTEPDSCH, cbIdx)
     2. Precoding performs linear transformations on the data of each
        substream to improve the overall receiver performance.
**** 6.7.5.1 Layer Mapping, pp225
     1. function out = LayerMapper(in1, in2, prmLTEPDSCH)
     2. Layer mapping divides a single data stream into substreams destined for different antennas.
**** 6.6.1 MIMO Resource Grid Structure
     1. Cell-Specific Reference (CSR)
     2. Figure 6.4 shows the locations of CSR and spectral nulls
**** 6.6.2 Resource-Element Mapping
*** 7 Link Adaptation
    1. Channel Quality Indicator(CQI), Precoder Matrix Indicator (PMI), and Rank Indicator (RI) measurements
** [#C] MATLAB for Digital Communication by Won Yang, book, 
\cite{Yang2009MATLAB}, 
  1. DL link: http://www.pdfdrive.net/matlab-simulink-for-digital-communication-e6520095.html
  2. http://gizemkahya.com/wp-content/uploads/2013/01/Matlab_s%C4%B1mul%C4%B1nk-for-dig.comm_..pdf
  3. http://wyyang53.com.ne.kr/
  4. http://www.pudn.com/downloads331/ebook/detail1453978.html
  5. http://www.general-community.com/forum/theme/gs3afefah5bi0-matlab-simulink-for-digital-communication-by-won-y-yang-pdf
  6. http://download.csdn.net/download/qiaokuangyi/2900759
  7. http://fr.mathworks.com/matlabcentral/fileexchange/25293-matlab-for-digital-communication
  8. http://199.195.143.28/matlab-for-digital-communication-won-yang.html
  9. 10: SPREAD-SPECTRUM SYSTEM
     1. *PN, DS, FH*
  10. 6.2 EQUALIZER
      1. 6.2.4 Decision Feedback Equalizer (DFE)
      2. do_dfe.m  [2015-06-26 Fri]
	 1. c=c+delta*e*ys; % Eq.(6.2.17a)
	 2. b=b-delta*e*ds; % Eq.(6.2.17b)
	 3. q(n)=c*ys'-b*ds'; % DTR input by Eq.(6.2.16)
	 4. [c,b]=dfe(c,b,ys,ds,e,delta); % DFE

*** STO, pp167
  1) Performance of CP-based STO estimation: maximum correlation-based
     vs. minimum difference-based estimation

** [#B] MIMO-OFDM Wireless Communications with MATLAB [Yong Soo Cho et al.] 2010
  1. \cite{cho2010mimo}, Maltab_MIMO.pdf, 

*** [#C] note

**** precoding | MMSE | STBC |, Equalization | LMS | RLS-(DFE)|
*** pp248, compare_DFT_spreading_w_psf.m”,  Figure 7.32 
    1. pp248
    2. % Figure 7.32 has been obtained by running Program 7.19 (“compare_DFT_spreading_w_psf.m”),
*** 7.2.1 Clipping and Filtering, pp224, PDF_of_clipped_and_filtered_OFDM_signal.m
    [2015-08-07 Fri]
    1. Program 7.11 “PDF_of_clipped_and_filtered_OFDM_signal.m”
    2. % Eq.(7.18b) limitation to CL
#+BEGIN_SRC octave
function [x_clipped,sigma]=clipping(x,CR,sigma)
% CR: Clipping Ratio, sigma: sqrt(variance of x)
if nargin<3
    x_mean=mean(x); 
    x_dev=x-x_mean;
    sigma=sqrt(x_dev*x_dev'/length(x));
end
x_clipped = x; 
CL = CR*sigma; % Clipping level
ind = find(abs(x)>CL); % Indices to clip
x_clipped(ind)= x(ind)./abs(x(ind))*CL; % Eq.(7.18b) limitation to CL
#+END_SRC
*** [#C] CFO_estimation.m
function CFO_est = CFO_CP(y,Nfft,Ncp)
% Nfft | FFT size, Ncp | CP size 
nn=1:Ncp; 
CFO_est = angle(y(nn+Nfft)*y(nn)')/(2*pi); 
*** [#C] STO_est.m

*** Block_diagonalization.m
 1. 13.3.2 Block Diagonalization
 2. Singular value decomposition, SVD, SVD奇异值分解
 3.         H1 = (randn(NR,NT)+j*randn(NR,NT))/sq2;
        H2 = (randn(NR,NT)+j*randn(NR,NT))/sq2;
        [U1,S1,V1] = svd(H1); 
        W2 = V1(:,3:4);
        [U2,S2,V2] = svd(H2); 
        W1 = V2(:,3:4);
        Tx_Data = W1*x(1:2,:) + W2*x(3:4,:);
*** Dirty_or_TH_precoding.m 
 1. 13.3.3 Dirty Paper Coding (DPC), p408
*** 12.2 Precoded OSTBC, Alamouti_2x1_precoding.m
    1. code_book = codebook_generator;
    2. He = H*code_book(:,:,Index); norm_H2 = norm(He)^2; % H selected
       and its norm2 for i=1:N_frame
       Rx(:,:,i)=He*Tx_symbol(:,:,i)+sigma*(randn(NR,2)+j*randn(NR,2));
       end

*** [#C] pre_MMSE.m, 12.3 Precoded Spatial-Multiplexing System
 1. It is clear that pre-MMSE equalization outperforms the
    receiver-side equalization schemes.
*** Alamouti_2x1_precoding.m, 12.2 Precoded OSTBC, P375
*** 12.4 Antenna Selection Techniques, P383
 1. antenna selection techniques can be used to employ a smaller
    number of RF modules than the number of transmit antennas.
 2. Figure 12.7 Antenna selections with Q RF modules and NT transmit
    antennas Q < N_T.

** [#B] Numerical Simulation of Optical Wave Propagation with examples in Matlab download
\cite{binh2014optical}, 
http://download.csdn.net/detail/opp77/4752566

Download
http://extabit.com/file/27aus4yd18063/0819483265.pdf
or
http://vip-file.com/download/77806.7ed7f26c706c3a0ad480e088f8e3/0819483265.pdf.html


* TODO [#B] MATLAB Error

** MATLAB [2014-12-29 Mon]
   1. 数字下变频Matlab 仿真
   2. http://blog.chinaaet.com/detail/27617

** MATLAB CMD

*** text(nd,Mag_dif(nd+com_delay+1), num2str(nd),'color','r','fontsize',24,'fontweight','b')
    [2015-06-09 Tue]

** ‘ replaced as ': case issue, THEN OK,  [2015-06-15 Mon]

** Undefined function or method 'filter_multi_IF' for input arguments of type 'double'.

*** ANS: have to add the path


* TODO @veri: verilog, @vhdl [2015-12-11 Fri]
  1. [2015-07-17 Fri]
  2. GONG Chaohua and ZHANG Haiyang

** [#C] @note start <2015-12-11 Fri>
*** @xilinx
**** CP210x USB to UART 
     1. https://www.silabs.com/products/mcu/Pages/USBtoUARTBridgeVCPDrivers.aspx
*** @key, @vhdl, @auto [2015-12-11 Fri]
**** @basic, @key, @auto, C-c C-p C-t,  /*AUTOWIRE*/   /*AUTOREGINPUT*/
     1. // @key, @auto, @lisp, model_name AUTO_TEMPLATE @"vl-cell-name"
     2. dpram_tb.v
     3. http://www.veripool.org/projects/verilog-mode/wiki/Faq#How-do-I-make-a-Testbench-module

#+TITLE:  /*AUTOREGINPUT*/ in dpram_tb.v
#+BEGIN_SRC verilog 

module ModnameTest;

   /*AUTOWIRE*/
   /*AUTOREGINPUT*/

   InstModule instName
     (/*AUTOINST*/);

   //==== Stimulus
   // You then put code here to set all of the inputs to the DUT.
   // The autos have created registers for all of the needed signals.

   //==== Stimulus
   // You then put code here to check all of the outputs from the DUT.
   // The autos have created wires for all of the needed signals.
endmodule
#+END_SRC

#+TITLE: C-c C-p in counter.vhd
#+BEGIN_SRC vhdl
-- @rev, INST, 1. COMPONENT, 2. PORT MAP
--  write information to the console: assert, severity and deallocate
-- assert i < 5 report "unexpected value. i = " & integer'image(i);
-- @emacs, C-c C-p C-c for component
                                        -- @emacs, 1. first C-c C-p C-w; 2. C-c C-p C-c
                                        -- @emacs, 1. first C-c C-p C-w; 2. C-c C-p C-t
                                        -- @emacs, inst, C-c C-p C-I      
#+END_SRC

*** @Emacs
    1. http://www.cnblogs.com/tureno/articles/2777282.html
*** AWG_8196A (optical, 92GSps):
*** AWG_8190A and R&S signal analyzer, DSP_20151029
  1. AWG, status/control must check
  2. signal analyzer, not oscilloscope 
*** AWG_8190A (wireless, 12GSps, 5G bandwidth, 12bit high quality):
 1. ADC
 2. AC (amply, 3V)
 3. DC (0.7V)
 4. source samp rate and baseband samp rate
    1. 自带的板子在最下面
    2. win7系统的板子 
    3. 8190A
    4. 4-5 可插拔的板子。跟tek相比 信号纯度很好 

*** NCO. (Numerically Controlled Oscillator) 

*** M8190A 12 GSa/s Arbitrary Waveform Generator
*** Virtex-6 Family, XC6VSX475T 
    1. http://www.xilinx.com/products/silicon-devices/fpga/virtex-6.html

*** [#C] big progress: HSDC_matlab  [2015-10-12 Mon]
      1. HSDCPro_Automation_DLL_DAC
	 1. The most time consuming part was at the begining;
            addpath(genpath('../../..')).
	 2. Your automation routine should be stripped down to the
            following 3 function calls
	 3. https://e2e.ti.com/support/data_converters/high_speed_data_converters/f/68/p/353982/1241194#1241194

      2. 实例化是这样的，greycode是你的module名字，G1是实例化名字（可
         任意），后面括号里的东东需要跟你定义的端口顺序一致。建议不要
         采用这种顺序绑定的形式，建议采用端口命名绑定方式

      3. http://e2e.ti.com/support/data_converters/high_speed_data_converters/f/68/p/356179/1249716
      4. C:\Program Files (x86)\Texas Instruments\High Speed Data
         Converter Pro\HSDCPro Automation DLL\Manual and Examples
      5. HSDCPro Automation DLL Manual.doc
      6. https://e2e.ti.com/support/data_converters/high_speed_data_converters/
      7. DAC38J84EVM + TSW14J56 with Matlab
	 1. https://e2e.ti.com/support/data_converters/high_speed_data_converters/f/68/t/364436
	 2. HSDCPro Automation DLL

*** no big progress, until [2015-10-12 Mon]
     1. only p/s and s/p
** fmc-adc-adapter [2015-12-18 Fri]

*** High Speed ADC to FMC (Xilinx) Header Adapter Card 
    1. http://www.ti.com/tool/fmc-adc-adapter

** [#C] @code, MFH_rx.v [2015-12-17 Thu]
*** mmwave.rx  [2015-12-21]
    1. ip core or not for lnum228 in mmwave.
    2. jesd204_in_transport_layer_demapper jesd204_in_transport_layer_demapper_
    3. how to set TI for lnum236 .signal0_sampl0(signal0_sampl0),
*** @chaohuag, Chaohua.Gong@alcatel-sbell.com.cn
    1. 对于228行的jesd204_in_transport_layer_demapper
       jesd204_in_transport_layer_demapper_i (); vivado没有这个ipcore
       吧, jesd204_in_transport_layer_demapper这个module是要自己设计的
       吗
       1. 这个模块我们有的，见附件。
    2. 这个代码是连接电脑USB的吧，而不是直接控制TI的FMC
       1. 是用Xilinx的下载线传数据的，不是使用TI的FMC。
    3. 对于236行的.signal0_sampl0(signal0_sampl0),等四个channel输入信号 如何在TI里设置
    4. 这个程序是针对SEU的板子的，只有JESD的参数配置部分是通用的

*** @test [2015-12-19 Sat]
    1. assign rxc=LMKsync;  // why wire both
**** @tcl, launch_simulation -help
     1. @err, focus on right (red) and previous err
     2. @key, @success, input/output must be defined in port declaration list ()
**** @err in mfh_rx_tb.v, port declaration not allowe
     1. ERROR: [VRFC 10-1241] port glblclk_n is not defined [D:/fpga_test/mfh_rx.v:40]
     2. ERROR: [VRFC 10-1249] port declaration not allowed in mfh_rx with formal port declaration list [D:/fpga_test/mfh_rx.v:
     3. ERROR: [VRFC 10-1241] port glblclk_p is not defined [D:/fpga_test/mfh_rx.v:41]
     4. ERROR: [VRFC 10-1249] port declaration not allowed in mfh_rx with formal port declaration list [D:/fpga_test/mfh_rx.v:41]
     5. ERROR: [VRFC 10-1241] port refclk_n is not defined [D:/fpga_test/mfh_rx.v:42]
     6. ERROR: [VRFC 10-1249] port declaration not allowed in mfh_rx with formal port declaration list [D:/fpga_test/mfh_rx.v:42]
     7. ERROR: [VRFC 10-1241] port refclk_p is not defined [D:/fpga_test/mfh_rx.v:43]
     8. ERROR: [VRFC 10-1249] port declaration not allowed in mfh_rx with formal port declaration list [D:/fpga_test/mfh_rx.v:43]
     9. ERROR: [VRFC 10-91] glbclkp is not declared [D:/fpga_test/mfh_rx_tb.v:72]
     10. ERROR: [VRFC 10-91] glbclkp is not declared [D:/fpga_test/mfh_rx_tb.v:73]

*** @test @jesd204, include shared clock in core
    1. wire signal0_sampl0 to I0 in always @(posedge   s_axi_aclk)
**** refclk_p | refclk_n | glbclk_p | glbclk_n | glblclk [2015-12-17] 
**** @jesd, logicore, jesd204_rx.v,  include shared clock in core [2015-12-17]
     1. glbclk_p
     2. include shared clock in core | not in example
     3. set globle clock

**** TL in module jesd204_in_transport_layer_demapper
     1. signal0_sampl0 in TL
     2. s_axi_wdata in case
**** ms_cnt_i | frame_cnt_i
     1. ms_cnt_i; // counter for 0.25ms, 0~34560
     2. F | 2, K | 24

*** jesd204_in_transport_layer_demapper

**** signal0_sampl0 and tl_ready;  // not included
     1. //`include "sine_lut64_14bit.vh"
     2. wire[15:0] signal0_sampl0;
     3. I0<=signal0_sampl0;
     4. wire tl_ready;
**** rx_aclk, rx_aresetn, rx_tdata, rx_tvalid // included in output in jesd204_in
**** in jesd204_rx.veo [2015-12-17]
     1. ----------- Begin Cut here for INSTANTIATION Template ---// INST_TAG

** [#C] @code, @auto, example.v [2015-12-16]

*** @verilog in async_transmitter.v
 1. Verilog-mode doesn't well support multiple modules in the same
    file, it's considered a bad practice; don't do it.

*** @lisp @github /*AUTOINSERTLISP*/
1. https://creatorjie.wordpress.com/2013/05/27/%E7%94%A8emacs%E5%86%99verilog/
2. //    .lower_inb (.lower_inb[@])   // @err
3. https://github.com/veripool/verilog-mode
4. The special form interactive turns a Lisp function into a command.

*** [#D] @hatena @lisp http://3-day-bouzu.hatenablog.jp/entry/2013/11/22/183158
1. mapconcat '(lambda (i)
   1. ((lambda (arg) (/ arg 50)) 100)
2. number-to-string, number-sequence
3. lambda is the symbol for an anonymous function, a function without a name.
4. mapcar, mapc, and mapconcat,

*** @jump [2015-12-14]
    1. How can I jump the cursor to the file that defines a module?
    2. Use \M-x verilog-goto-defun (C-c\C-d).

*** /*AUTORESET*-AUTOREGINPUT/ // in always 
    1. http://www.veripool.org/projects/verilog-mode/wiki/Examples
    2. /*AUTOWIRE*/ in submodule, [2015-12-10]
    3. /*AUTOREGINPUT*/ [2015-12-11]
    4. @"vl-cell-name"_lower_ina [2015-12-11]

*** IBUFDS
    1. http://blog.csdn.net/crazy_night/article/details/42639965
    2. 差分传输是一种信号传输技术，区别于传统的一根信号线一根地线的做
       法，差分传输如图所示，在这两根线上都传输信号，这两个信号的振幅
       相等，相位相反，在这两根线上的传输的信号就是差分信号。
    3. //对差分时钟采用IBUFGDS IP核去转换
    4. 差分信号的输入是成对分配的，并且I/O标准是默认LVDS模式
    5. 低压差分信号(Low Volt-agc Differential signaling)
    6. 低压差分信号相对于单端的传送具有较高的噪声抑制功能，其较低的电压摆幅允许差分对线具有较高的数据传输速率，消耗较小的功率以及产生更低的电磁辐射。
    7. (IN+ + q) — (IN- + q) = IN+ — IN- = OUT
    8. http://home.eeworld.com.cn/my/space-uid-100454-blogid-30594.html

*** @generic defparam and # verilog 参数传递 # in top module
    1. 类似VHDL的Generic语句，Verilog也可以在例化时传递参数
    2. 传递的参数是子模块中定义的parameter。
    3. 被引用模块名 # (参数1,参数2,…)例化模块名(端口列表);
    4. 高层模块可以改变低层模块用parameter定义的参数值
    5. mod mk(out,ina,inb); // 对模块mod的实例引用
    6. defparam mk.cycle = 6, mk.file = "../my_mem.dat"; // 参数的传递
    7. mod # (5, 3.20, "../my_mem.dat") mk(out,ina,inb); // 对模块mod的实例引用
    8. defparam heirarchy_path.parameter_name = value;

** debug, verilog (*mark_debug="true"*)
   1. Tools->Set Up Debug
   2. MARK_DEBUG
   3. attribute mark_debug of counter : signal is "true";
   4. 需要把想要观测的信号标记出来，即mark_debug
   5. counter信号前面有一个绿色的小蜘蛛，表示counter信号被标记出来了。

** xdc约束文件 set_property

** [#C] @code, @jesd in jesd204_1_tb.v [2015-12-16]
   
*** @test, [2015-12-16]
     1. rx_reset,  rx_sysref and s_axi_aclk, s_axi_aresetn not working
     2. only rx_core_clk working   
     3. @key initial must after task
     4. rx_core_clk | rx_aclk
     5. rx_reset   | rx_aresetn
     6. @success, restart vivado for xsim xil_defaultlib, @err,
        ERROR: [XSIM 43-3225] Cannot find design unit
        xil_defaultlib.jesd204_1_tb in library work located at
        xsim.dir/work..

     7. ERROR: [VRFC 10-552] declarations not allowed in unnamed block [D:/fpga_test/jesd204_1_tb.v:143]
  
***  jesd204_1_tb.v work only rx_core_clk, but X [2015-12-16]
  1. JESD204 VHDL example design
    1.1 the core is only supported in Verilog at this time.
  2. @codebus, ansel1986, but need 1 coins, jesd204_wrapper.v, http://www.codebus.net/d-LAo0.html

*** @github, @code, ad_jesd_cntrl.v
 1. https://github.com/analogdevicesinc/fpgahdl_xilinx/blob/master/cf_lib/edk/pcores/adi_common_v1_00_a/hdl/verilog/ad_jesd_cntrl.v


***  @fpga @fpga4fun, adc fpga interface, rx_sysref, device clk and LMFC, [2015-12-15]
1. SYSREF Input. When Subclass 1 mode is selected, this signal is required and used by the core.
2. Clocking, pp43
3. Figure 3-12: FPGA Receive Timing
4. SYSREF LMFC
5. The core does not deassert SYNC until an initial SYSREF event is detected
6. device clk | SYSREF | LMFC
7. adc fpga interface, SDR  Single Data Rate (SDR), 
 7.1 http://surf-vhdl.com/how-to-connect-an-adc-to-an-fpga/
 7.2 Digital oscilloscope - dual-port RAM
 7.2.1 http://www.fpga4fun.com/digitalscope_hdl2.html


*** Port Descriptions
as a rx of 1 lane, from example in pg066-jesd204, v6.0 @logicore, [2015-12-09]
1. K (Frames per Multiframe)
2. F (Octets per Frame), octet (byte) clock rate can be directly inferred (F octets per frame).
3. SYSREF handling (for Subclass 1 mode)

**** local multiframe clock (LMFC)
  
*** Management Interface (AXI4-Lite)
1. see the Xilinx Vivado AXI Reference Guide (UG1037) [Ref 14]
2. ug1037-vivado-axi-reference-guide.pdf
3. Xilinx adopted the Advanced eXtensible Interface (AXI) protocol
4. Table 2-13: Management Interface (AXI4-Lite) (Contd), [2015-12-11]

*** gt0_, The interface between the core and the transceiver, [2015-12-14]
1. Receiver with Shared Logic in Example Design
2. @github, AXI JESD204B GT HDL Linux Driver
3. The AXI JESD204 GT HDL driver is the driver for the Gigabit Tranceiver (GTX, GTH, etc.) HDL interface core which is used on various FPGA designs.
4. JESD204b (GT) interface to DAC/ADC
5. pp18,  gtN_rxdata, Table 2-9: RX Core: Transceiver Interface Ports - Shared Logic in Example Design.
6. gtN_rxcharisk[3:0] | In | RX Char is K from transceiver. N = Lanes-1
7. @github, https://github.com/analogdevicesinc/hdl/tree/master/library/axi_jesd_gt 
8. <component_name>_support.v, Sharing Transceivers between Transmit and Receive

** @kc705, @jesd
*** My own PCIE core
    1. https://forums.xilinx.com/t5/7-Series-FPGAs/My-own-PCIE-core/td-p/669289
       1. PCIE cards mostly use GT transceivers for sending and receiving data
       2. I'm looking at getting a KC705 board, with a Kintex-7 on it.
          Xilinx  already has PCIE cores 

*** [#B] @kc705 @ti

**** @jesd in local pc
     1. C:\Program Files (x86)\Texas Instruments\High Speed Data Converter Pro\14J10KC705 Details\ADC files

**** JESD data corruption (KC705+ADC16DX370EVM)
     1. http://e2e.ti.com/support/data_converters/high_speed_data_converters/f/68/p/466492/1674780
     2. I tried JESD cores 6.1 and 6.2 (Vivado 2015.2, 2015.3)
     3. ADC16DX370EVM_TSW14J10EVM_KC705
     4. http://download.sourcecodeprojects.com/1623503/

*** [#D] JESD204 A/B IP Core for XILINX Kintex, @finance, US $450.00, @ebay
    1. ADC 250 Msps to FPGA through JESD204b serial lanes
    2. http://www.ebay.co.uk/itm/JESD204-A-B-IP-Core-for-XILINX-Kintex-ALTERA-/321514835781

*** [#C] JESD204B @kc705, @vivado, JESD-v6.0
    1. pg066-jesd204.pdf
       1. Detailed Example Design
       2. Configuration Tab, pp74
    2. tidu171.pdf
       1. http://www.ti.com/lit/ug/tidu171/tidu171.pdf
    3. LogiCORE™ IP JESD204 core
       1. http://www.xilinx.com/products/intellectual-property/ef-di-jesd204.html
       2. JESD204B specification describes serial data interface and the link protocol between data converters and logic devices.
    4. JESD Converter EVM to FPGA EVM adapter 
       1. http://www.ti.com/tool/tsw14j10evm
       2. Provides the interface between High Speed Data Converter EVM’s and FPGA Development board through two FMC connectors.
	  1. Xilinx KC705, ZC706, VC707 and KCU105 platforms

*** UG883, ug883_K7_KC705_Eval_Kit

**** @note
     1. UART
       	1. USB-to-Mini-B cable (for UART)
     2. JTAG
     3. SW11
       	1. mode switches (SW11)
     4. Agile Mixed Signal (AMS)
     5. built-in self-test (BIST)

**** @tutorial
     1. Install the UART Driver, pp12
     2. AMS Bring-up with the AMS101 Evaluation Card
	1. no need
     3. built-in self-test (BIST) tests, @logicore
	1. LogiCORE IP Integrated Bit Error Ratio (IBERT) core
	2. ChipScope™ Pro analyzer
	3. to create a pattern generation and verification design to
           exercise the Kintex-7 FPGA GTX transceivers
     4. Hardware Bring-Up, pp25, @linux, Advanced Operation for PCIE
	1. insert the KC705 board in the PCIe slot
	2. After Fedora 16 Core boots
	3. lspci
	4. Targeted Reference Design (TRD)
	5. Enables hands-on operation

*** UG810
    1. ug913-kc705-getting-started.pdf
       1. Running the Video Demonstration
       2. Figure 1-2:Kintex-7 FPGA Video Demonstration Hardware Setup
    2. ug810_KC705_Eval_Bd.pdf
       1. http://www.xilinx.com/support/documentation/boards_and_kits/kc705/ug810_KC705_Eval_Bd.pdf
** @fpga4fun
*** Direct Digital Synthesis (DDS) - Introduction for DAC as an AWG
    1. 基于数字频率合成(DDS)技术
    2. http://www.fpga4fun.com/DDS1.html
    3. 不仅仅只是sin、cos、方波、锯齿、三角，可以是任何波形哦
    4. DDS电路采用FPGA实现，单片机控制整个系统，产生任意波形

** @github, /verilog 100 examples/
   1. https://github.com/vlsi1217/ASIC/tree/master/verilog%20100%20examples
** @tcl, xsim, Path of setenv
*** xsim, snap shot 
    1. snap shot | pam4_tb1_behav.wcfg
*** ug835, write_project_tcl, p1037
    1. write_project_tcl -force recreate.tcl
*** cd D:/fpga_test/project_qam, not cd D:\fpga_test\project_qam
*** open_project project_qam.xpr
*** [#C] Path | C:\Xilinx\Vivado\2014.4\bin
    1. @err, vivado | C:\Xilinx\Vivado\2014.4\bin
    2. set PATH=%PATH%
    3. setx ENV_VAR_NAME "DESIRED_PATH" /m
       1. This will change it permanently and yes you can overwrite it by another batch script.

** [#D] Xilinx vs Altera [2015-11-18 Wed]
   1.  In the FPGA world, that feud is Xilinx vs Altera. This spirited
       rivalry has spanned the space of three decades

** [#D] @key, @fpga, ifft [2015-11-18 Wed]
*** @fpga LTE FFT v2.0, logicore
    1. LogiCORE IP LTE Fast Fourier Transform v2.0 
*** @fpga, logicore IP FFT v9.0
   1. clocking
   2. event signals
   3. s_axis_config_tdata
      1. Carries the configuration information: CP_LEN, FWD/INV,NFFT and SCALE_SCH.
      2. FWD_INV
	 1. When FWD_INV = 1, a forwardtransform is computed. If
            FWD_INV = 0, an inversetransform is computed.
      3. NFFT
	 1. The value of NFFT is log2 (point size).
      4. Table 3-4: Configuration Channel TDATA Example
   4. s_axis_data_tdata
      1. Carries the unprocessed sample data: XN_RE and XN_IM
   5. m_axis_data_tdata
      1. Carries the processed sample data XK_RE and XK_IM.
   6. Demonstration Test Bench
      1. When the core is generated using the Vivado Design Suite, a
         demonstration test bench iscreated.

*** tb_xfft1.v
      1. FFT v9.0 Core simulation problem in Vivado 2014.2/2015.1!
      2. https://forums.xilinx.com/t5/DSP-and-Video/FFT-v9-0-Core-simulation-problem-in-Vivado-2014-2-2015-1/m-p/649889#M9770\
      3. FPGA Xilinx FFT v8.0 core example testbench
	 1. http://stackoverflow.com/questions/30237757/xilinx-fft-v8-0-core-example-testbench

** @pass, ansel_1986, ug937-design-files.zip, DDS, sine, KC705
   1. https://secure.xilinx.com/webreg/clickthrough.do?cid=356053
   2. In the IP catalog, double-click the DDS Compiler IP,
   3. Using Breakpoints
   4. 10.  In the Default Part dialog box, specify Boards, and select
      Kintex-7 KC705 EvaluationPlatform, and click Next.

** [#C] @key, /dpram.v and dpram_tb.v/
   1. [2015-11-30 Mon]
   2. [[http://pgandhi189.blogspot.fr/2014/11/dual-port-ram-implementation-in-verilog.html][ln:dpram]]
*** task stimulus
    1. stimulus(i,($random));
    2. task stimulus(input[3:0] i, input [7:0] j); //[HDL 9-806] Syntax error near "begin".
*** write and read // *else if(rd) -> if(rd)*, *clk->clk4*
#+NAME: "clk4 in dpram1.v"
#+BEGIN_SRC verilog 
  always @(posedge clk4) begin 
     if(rd)
      data_out<=mem[rd_addr]; // clk to clk4, then 3rd data obtained, [2015-12-02]
      // so i->i-2, rd_addr =i-2; // rd_addr =i; // in dpram_tb1.v
      // @success, [2015-12-02]
  end 
  
#+END_SRC

#+BEGIN_SRC verilog 
always @(posedge clk) begin 
   if(reset)
   begin
     for(i=0;i<depth;i=i+1)
        mem[i]<=0;
   end
   else begin
   if(we)
//    mem(wr_addr)<=data_in;  //[HDL 9-806] Syntax error near "<=". ["D:/fpga_test/dpram.v":27]
    mem[wr_addr]<=data_in;
//   assign  mem(wr_addr) <= data_in;
//   if(rd)
//   else if(rd)
   if(rd)
//   mem(data_out)<=mem(rd_addr);
    data_out<=mem[rd_addr];
   end // else: !if(reset)  
end
#+END_SRC
*** @err, mem(i)
    1. sim(i,($random)); // width max is 32 for random
       1. parameter width = 8; // 64 and 1024 is wrong
       2. Verilog “$random函数调用时返回一个32位的随机数,它是一个带符
          号的整形数
       3. 8 bit for 64QAM
    2. mem[i]<=depth'b0; // depth'b0->0
    3. //        mem(i)<=8'b0;  //[HDL 9-806] Syntax error near "<="
    4. //always @(posedge clk)
    5. always @(posedge clk) begin 

** [#C] @key, big process, write test-bench and /PAM4.v and pam4_tb1.v/, and /rand1_tb.v/ [2015-10-21 Wed]
*** @key, @err
    1. *output should be redefined reg type*, otherwise can not assign
       in module
       1. output x;
       2. reg x; // first output, must be reg in module, //output x;
       3. in /rand1_tb.v/
    2. testbench
       1. only reg and wire
       2. *assign must with initial*
    3. assign can only to reg type
       1. ERROR: [VRFC 10-1280] procedural assignment to a non-register x is not permitted,
    4. parameter can not be operated, *2*delay*
    5. integer max = 4096;  // as an input
*** pam4_tb1.v, /pam4.v and rand1.v/  [2015-11-26 Thu]
    1. 2 modules included [2015-11-27 Fri]
    2. rand = $random(seed); // % 10000;
    3. while(i<max) begin  // i= 50
    4. //  for(i=0; i<max; i=i+1) begin // i= 50
    5. //  always @(i) begin // @err
    6. forever begin  // @key, forever must be with initial begin, not initial
    7. // @err, #2*delay -> 20 for delay;
*** write test-bench by myself and PAM4
  1. PAM4 from http://www.cnblogs.com/madtime-inside/archive/2011/08/04/2127081.html
     1. 基于Verilog的4-PAM
  2. analog setting-->interpolation style-->hold
*** Xilinx FFT IP core 笔记, Xilinx FFT IP core datasheet
   1. Vivado HLS,
      1. C:\Xilinx\Vivado_HLS\2014.4\examples\design\FFT\fft_ifft
   2. radix-2, lite, burst i/o
   3. Fast Fourier Transform v9.0
   4. DS260, Fast Fourier Transform v4.1
      1. xfft_ds260.pdf
      2. http://guqian110.github.io/pages/2014/09/02/xilinx_fft_core_notes.html
   5. Implementation of Fast FourierTransform (FFT) on FPGA using
      Verilog HDL
      1. FFT的verilog实现详解
** [#C] @key, /readm.v and sine_tb/, 学习testbench（2）----文件的读写, display, fdisplay and fscanf
   1. [2015-11-18 Wed]
*** /sine_tb/, @matlab, ADC 
      1. $readmemh("D:/matlab1411/data/sin.txt",data_mem); //
      2. always @(i)
      3. #delay $fdisplay(w_file,"%h",data_mem[i]);  // @key, i=0:255, [2015-11-25]
      4. #delay $fclose(w_file);  // @key, make sure i=255
      5. //x = fix(128 + (2^7 - 1) * sin(2*pi*n/N));  % @maltab
***  /readm.v/
   1. /readm.v/
      1. reg [15:0] mem[3:0]; // @key,mem[3:0][15:0], first col, then row, [2015-11-19 Thu]
      2. $readmemb("D:/matlab1411/data/mem.txt",mem);
      3. #10 $fdisplay(fid,"%b", mem[addr]);  // @key, right for binary
   2. filename”中的路径要用反斜杠'/'，而不是斜杠'\'，切记！
   3. http://www.infineon-ecosystem.org/ssagittis/blog/15-01/307821_58db7.html
   4. testbench 的文件读写操作(转载),@addr bi_stream 
      1. file_name:可以是.txt、.doc等格式的文件，但必须遵守ROM的规范，即其内容形式必须@00
      2. http://www.cnblogs.com/iqstudy/articles/1853552.html
** quotation on FPGA boards
   1. FPGA-VCU108 (Xilinx), qty: 1
      1. http://china.xilinx.com/products/boards-and-kits/ek-u1-vcu108-es-g.html
   2. FPGA-TSW14J56EVM (TI), qty: 2
      1. http://www.ti.com/tool/tsw14j56evm
   3. DAC38J82EVM (TI), qty: 1
      1. http://www.ti.com/tool/dac38j82evm#64
   4. ADC12J2700EVM (TI), qty: 1
      1. http://www.ti.com/tool/adc12j2700evm
   5. Altera EP4S100G AMC FPGA, qty:1 
      1. http://www.vadatech.com/product.php?product=167&catid_prev=135&catid_now=61
   6. \cite{li2015real}, 200Gbps, \cite{li2015realization}, Invited,
      \cite{li2013real}, \cite{xiao2014100}
      1. *JESD204B or SERDES*
	 1. serializer/ deserializer (SERDES) JESD204B
      2. Mo.4.5.5 • 17:30-17:45
      3. Real-time Direct-detection of Quad-carrier 200Gbps 16QAM-DMT
         with Directly Modulated Laser
      4. Fan Li1, Jianjun Yu1;1ZTE TX, Morristown, United States
      5. We demonstrated four-channel WDM 256.51Gb/s 16QAM-DMT
         short-reach optical-amplifier-free inter-connection with
         real-time reception. We achieved highest capacity DMT signal
         transmission over 2.4-km SMF with the BER under SD-FEC
         limitation of 2.4×10-2.


| Devices               | Qty. | Price(￥) | Total (￥) | 供货期 |
|-----------------------+------+-----------+------------+--------|
| PFGA-VCU108 (Xilinx)  |    1 |  74400.00 |   74400.00 | 6-8周  |
|-----------------------+------+-----------+------------+--------|
| FPGA-TSW14J56EVM (TI) |    2 |  12000.00 |   24000.00 | 4-6周  |
|-----------------------+------+-----------+------------+--------|
| DAC38J82EVM (TI)      |    1 |   6000.00 |    6000.00 | 4-6周  |
|-----------------------+------+-----------+------------+--------|
| ADC12J2700 (TI)       |    1 |  16800.00 |   16800.00 | 4-6周  |

** test-bench

*** FPGA学习手记（四）ModelSim入门及Testbench编写 
    1. #20 c_in = 2'b01; 
       1. c_in = 2'b01; #20;  different, 
    2. 信号定义、模块接口和功能代码 (time)
       1. 一个最基本的Testbench包含三个部分，信号定义、模块接口和功能代码
       2. http://maxim.eefocus.com/nightseas/blog/12-03/242395_7df71.html
** @err [2015-09-23 Wed]
*** always语句外的赋值要加上关键字assign,称为连续赋值
*** //task write() // //[HDL 9-806] Syntax error near "begin".
    1. task write();
*** place_design Error

** [#C] ipcore, /fft_tb.v and ip_demo.v, big progress/; DPRAM, memory_16x4_bi.v  [2015-09-17 Thu]

*** [#C] fft_tb.v from IP core | FFT-v9.0; component | xfft_0,  [2015-11-18 Wed]
    1. // size mismatch, 7 to 15
    2. //    reg [7:0] s_axis_config_tdata;
    3. reg [15:0] s_axis_config_tdata;
    4. http://communitysupport.xyz/question/30237757/xilinx-fft-v8-0-core-example-testbench
*** [#C] ip_demo.v, .veo from IP Sources  [2015-11-18 Wed]
#+BEGIN_SRC  verilog
mult_gen_0 your_instance_name (
//  .CLK(CLK),  // input wire CLK
  .CLK(clk),  // @key, careful
  .A(A),      // input wire [17 : 0] A
  .B(B),      // input wire [17 : 0] B
  .P(P)      // output wire [35 : 0] P
);
#+END_SRC
   1. [2015-11-18 Wed]
*** [#C] Vivado中ROM/RAM IP核的使用, really start. 选择IP Sources .veo  [2015-10-10 Sat]
    1. Xilinx Vivado的使用详细介绍（3）：使用IP核
       1. http://www.hainter.com/vivado-ram-ip-core
       2. 调用IP核
	  1. 选择IP Sources，展开并选择mult_gen_0 - Instantiation
             Template - mult_gen_0.veo，可以打开实例化模板文件

    2. Block Memory为块存储设备，这里需要的是Distributed Memory Generator
    3. *Distributed Memory Generator*
    4. ROM的初始化, COE文件
    5. 调用方法
    6. // INST_TAG_END ------ End INSTANTIATION Template ---------
*** Memory elements like RAM/ROM are the heart of Digital Design
    1. in the above code "reg [7:0] mem[15:0];" indicates that there is
       a memory element whose width is 8 and whose depth is 16,so to
       address that memory locations we need a total of 4 address bits
       (2^4=16). So for our design we have used the address 4 bit
       wide.
    2. http://pgandhi189.blogspot.fr/2014/11/dual-port-ram-implementation-in-verilog.html
*** writememh.v, err
    1. // for(i=0;i<16;i++) begin
    2. for(i=0;i<16;i=i+1) begin
*** [#D] memory_16x4_bi_tb.v and  memory_16x4_bi.v, Success
    1. forever #50 clk=~clk;
    2. data_out = memory[address];
*** rom_tb.v, and memory.list, err
    1. reg [7:0] mem [0:255] ;
    2. $readmemb("memory.list",mem);
*** memory_tb.v and mem_ram_sync.v, fail
    1. reg [0:3] memory [0:15];
    2. forever #50 clk=~clk;
    3. module memory_16x4_bi(data, clk, out_en, address, rd_en, wr_en );
*** Memories Verilog models memory as an array of regs
    1. \\ a 1k word memory with 32-bit words
    2. reg[31:0] dmem[0:1023]; 
*** do tdd
** @ti, ADC12J2700EVM和TSW14J56, High Speed Data Converter Pro GUI, 2.7GSPS
   1. high-speed data converter evaluation platform. (HSDCEP) 
   2. TSW14J56EVM
      1. Quickly evaluate JESD204B DAC and ADC performance using TI
         High Speed Data Converter Pro software
      2. Direct connection to all TI JESD204B High Speed Data
         Converter EVM’s using an FMC standard connector
      3. http://www.ti.com/tool/tsw14j56evm
   3. @zhang_haiyang TI设备型号 [2015-09-09 Wed]
      1. 发端板子两个，DAC38J84EVM和TSW14J56
      2. 收端板子两个，ADC12J2700EVM和TSW14J56，如果不做FPGA编程的话，咱
	 们没必要知道其型号吧

   4. texas Instruments (TI) TSW14J10 Evaluation Module (EVM)
   5. http://www.ti.com/tool/dataconverterpro-sw
   6. ADC12J4000 (ACTIVE)
      1. 12-Bit, 4.0 GSPS RF sampling ADC with JESD204B interface 
   7. 2.7GSPS, 4-bit Oversampling, 500MHz,  
   8. Analog IF to digtal BB.
   9. IT_SERVICE.China@alcatel-sbell.com.cn
   10. http://e2e.ti.com/support/data_converters/high_speed_data_converters/
** @vivado projects 
# replace of ISE #
*** code design
**** delay
***** //   #20 si = 1'b0;
   si = 1'b0;
   #20;

**** module vs test-bench
     1. [2015-08-19 Wed]
***** module is input, output and reg
***** module_tb is reg, parameter, and wire; 'include and 'timescale; initial begin end

*** parameter nchn = 4;  parameter nchn = 1'd4;

*** project_2, compare
**** compare.v
     1. compare compare1(.equal(equal),.a(a),.b(b)); //调用模块。
*** project_1, count
**** count4.v
always @(posedge clk)
begin
if (reset) out<=0; //reset
else out<=out+1; // count
end
*** 用户约束文件格式(UCF,User Constraint File)
***  tcl
     1. Overview of Tcl Capabilities in Vivado. The Tool Command Language (Tcl) 
** @vhdl
*** difference, ADA-like vs C-like
    1. VHDL is “harder” to learn ADA-like.
       1. Ada基于Pascal语言
       2. EDA: Electronic Design Automation Tools
    2. Verilog is “easier” to learn C-like.
    3. 虐爆了我这个只知道pascal,C,BASIC这3种语系
       1. 这就是以电脑先驱帕斯卡的名字命名的PASCAL语言
#+BEGIN_SRC ada
with Ada.Text_IO; 
procedure Hello is
begin
    Ada.Text_IO.Put_Line("Hello, world!");
end Hello;
#+END_SRC

** Xilinx virtex (best), kintex, artex, KC705 (FMC pair), Virtex-6
    1. http://www.xilinx.com/products/silicon-devices/fpga/virtex-6.html
** shift reg: r<= {r, 1'b0} in always @(posedge clk)
** [#D] @key, @tdd: @veri, /p2s.v and s2p.v/, 
*** [#C] @efy, tdm.vhd, efytdm.vhd, Simulation of time-diViSion-multiplexer uSing VHdl
    1. http://www.electronicsforu.com//EFYLinux/efyhome/cover/November2009/Soft1_Nov09%281%29.pdf
    2. electronicsforu.com
    3. -- signal generator
    4. -- Main unit TDM
    5. mainp: process(s1,s2,s3,s4,sel,din,mclk)
       1. end process mainp;
#+BEGIN_SRC VHDL
sels: process(mclk)
variable temp:integer:=0;
begin
if mclk ='1' and mclk 'event then
temp := temp +1;
end if;
sel<= CONV_STD_LOGIC_VECTOR(temp,2);
end process sels;

- 程序 5-34
PROCESS (clock)
IF (clock’EVENT AND clock ='1' ) THEN
Q <= DATA ;
END IF ;
END PROCESS;
#+END_SRC
*** @wenku 多路复用信号产生电路的建模与VHDL设计
    1. http://wenku.baidu.com/view/c1a8809a51e79b89680226e4.html
*** 4.4 将复用解复用综合起来
#+BEGIN_SRC verilog 
module fyjy41(clk, clk4,a, b, c, d,sel, q,e,f,g,h);

input clk;

input clk4;

input   a,b,c,d;

input   [1:0]sel;

output e,f,g,h;

output q;

reg   [0:3]q;

reg e,f,g,h;

 always @(posedge clk4)

begin

 if (clk4)    

  case(sel)

        2'b00:  e=q[0];

        2'b01:  f=q[1];

        2'b10:  g=q[2];

        2'b11: h=q[3];

       endcase

end

always @( posedge clk)

begin

if (clk)

    case(sel)

  2'b00:  q[0]=a;

  2'b01:  q[1]=b;

  2'b10:  q[2]=c;

   2'b11:  q[3]=d;

endcase

else

deassign q;

end

endmodule

#+END_SRC
*** 4.1 四选一选择器的设计 always @(sel)
#+BEGIN_SRC verilog 
module mux41( a, b, c, d, sel, q);

         input   a,b,c,d;

         input   [1:0]sel;

         output  q;

         reg    q;

         always @( sel)

         case(sel)

          2’b00:  q=a;

          2’b01:  q=b;

          2’b10:  q=c;

          2’b11:  q=d;

          endcase

          endmodule

#+END_SRC
*** 4.2 四位数据复用的设计  always @( posedge clk)
    1. 设计思想是：将输入的a、b、c、d四位数据复用在一条信道上传输，本
       次设计是采用时分复用所以此次的信道是可以用时隙来描述。要将四位
       数据复用到一条信道上传输则需要用时钟来控制，由选择信号sel[1:0]
       来决定选择哪个输入信号。

    2. http://blog.163.com/asforme_love@yeah/blog/static/8877014020096239514125
#+BEGIN_SRC verilog 
module fuy41(clk, a, b, c, d, sel, q);

input clk ;

        input   a,b,c,d;

        input   [1:0] sel;

         output  q;

         reg    q;

      always @( posedge clk)

       case(sel)

        2’b00:  q=a;

        2’b01:  q=b;

        2’b10:  q=c;

        2’b11:  q=d;

       endcase

      endmodule

#+END_SRC  

*** p2s and s2p
    1. out[4*i+3 -: 4] = in[i];
       1. // Solution using indexed part select
       2. for (i = 0; i < N; i = i + 1) out[4*i +: 4] = in[i]; 
	  1. which causes the other end of the range to be (start-(width-1)) 
       3. out[4*i+3 -: 4] = in[i];
    2. @cnblogs [[http://www.cnblogs.com/oomusou/archive/2009/10/24/p2s_s2p.html][@cnlogs:musou]]
       1. (原創) 如何將parallel轉成serial?如何將serial轉成parallel? (SOC) (Verilog) 
       2. s2p
	  1. r <= {r, in}
	  2. assign out = en? r: 4'b0
       3. p2s
	  1. r<={r,1'b0}
	  2. assign out = r[3]
# http://forums.xilinx.com/t5/Simulation-and-Verification/2014-3-VIVADO-Simulator-error/td-p/531071
#+BEGIN_SRC verilog 
module top(
    input rst, ce,
    input clk,
    output reg [15:0] out_b
    );
    
   parameter COUNTER_WIDTH = 16;

   initial out_b = {COUNTER_WIDTH{1'b0}};

#+END_SRC
** mux_2to1_gates.v //待测试的2 选1MUX 模块
   1. http://www.asic-world.com/code/hdl_models/mux_2to1_gates.v

     
* TODO [#B] Opti, Optisystem

** @key: RoF1503v2.osd, OFDM_tx1503.m
[2015-03-04 Wed]
*** fiber |w/o |B2B | 30km , EVM |0.0017|0.082 |0.0827; B2B, like w filter- dispersion; 
30km, same as B2B
*** OFDM_tx0607.m, when B2B, EA from 20 |10| into | -10 | -10|


** @key: RoF1503.osd from RoF0608v7.osd and OFDM_tx0607.m
*** [#B] @key: delete 2 guassian optical filters and 1 optical amplifier, performance better for 4QAM
[2015-03-03 Tue]
filter will make optisystem very slow, and signal power lower
*** @key: InputPort1.Sequence and Parameter1, sequence length and samples per bit
*** fdesign.lowpass
*** previous only 4QAM
** @key: PhD_ML_VPI.pdf, MATLAB+VPI, in bib1410-->paper1410
** OFDM_trx1503.m
*** @key: previous only 4QAM can work, 16QAM not try, today try, but fail.
*** @key: focus on Nfft | binary length | Q, 256-(128) | 2048-(8192) | 8, RF from 5G into 1G
*** @key: cc should add, then Success for  train sequence
cc = Nfft/sqrt(Nsd); % [2015-02-27]
xifft   = cc*ifft(xmapa); % [2015-02-27]
*** xsym, bin_length
% xsym = randsrc(Nsd,(Nfrm-1)*Nrun,[0:M-1]); 
% [2015-01-05], from HXA_MFH141229s1.m
xbi = binary; % [2015-02-26]
x0         = reshape(xbi,k,length(xbi)/k);
xsym0       = bi2de(x0.','left-msb');
xsym = reshape(xsym0,Nsd,(Nfrm-1)*Nrun); % [2015-02-26]

